# Global SDLC Orchestration System

## AI Stack ($420/month)

- **Claude Max** ($200): Primary orchestrator, 900 msg/5hr, Opus + Sonnet
- **ChatGPT Pro** ($200): Codex CLI (GPT-5.2-Codex) for prototyping, o3-pro for debugging
- **Google AI Pro** ($20): Gemini 2.5/3 Pro, 1M token context

## PDF File Handling (CRITICAL - DO NOT VIOLATE)

**NEVER read PDF files directly with the Read tool.** This causes encoding issues and corrupted output.

**Instead, use the PDF analysis system:**
1. Extract text first: `pdftotext file.pdf file.txt` or use docx extraction
2. For images in PDFs: Use image extraction tools
3. If `.extracted.txt` or `.docx.txt` exists, read that instead
4. For complex PDFs: Ask user to provide extracted content

**Why this matters:**
- Direct PDF reads produce garbled binary output
- Wastes context tokens on unusable data
- May crash or hang the session

**Allowed PDF operations:**
- `pdftotext`, `pdf2txt.py`, `pdfplumber` for text extraction
- `pdfimages` for image extraction
- Reading pre-extracted `.txt` files

## 95 Specialized Agents

**Categories (14):** General(6), Planning(8), Backend(10), Frontend(10), Database(6), Testing(8), Quality(8), Security(6), Performance(5), DevOps(8), Cloud(5), AI/ML(7), Integration(4), Business(4)

**Key agents:** `/agents/<category>/<name>` - Use via Skill tool

## 5-Phase Development Discipline (CCPM)

1. **Brainstorm**: `/sdlc:brainstorm` - Gather requirements, ask clarifying questions
2. **Document**: `/sdlc:spec` - Create specifications with acceptance criteria
3. **Plan**: `/sdlc:plan` - Technical design, mission breakdown (AB Method)
4. **Execute**: `/sdlc:execute` - Implement with parallel/sequential agents
5. **Track**: `/sdlc:status` - Monitor progress, update stakeholders

## Hybrid Adaptive Workflow

- **Sequential**: Dependent tasks (backend before frontend, types before components)
- **Parallel**: Independent tasks (git worktrees for isolation, CCPM pattern)
- **Decision Logic**: Task router determines execution mode based on dependencies

## Quality Gates (Never Compromise)

- All PRs require: `/review` + `/test`
- Security-sensitive code: `/security-review`
- Architecture changes: architect agent approval
- Critical changes: Multi-agent consensus (Claude + Codex + Gemini)
- Minimum test coverage: 80%
- Zero critical security vulnerabilities

## ENFORCED MULTI-AGENT PARALLELISM (CRITICAL REQUIREMENT)

### Minimum Agent Requirements
**ALWAYS run at least 9 CONCURRENT agents** (3 Claude + 3 Codex + 3 Gemini) at ANY time.
**Total invocations per task: 21 agents across 3 phases.**
**CRITICAL: At least 9 agents (3Ã—3) MUST be running simultaneously throughout ALL work.**

| Activity Type | Min Concurrent | Distribution (3+3+3) |
|--------------|----------------|----------------------|
| **Planning** | 9 | 3 Claude (architecture, security, specs) + 3 Gemini (context, codebase, patterns) + 3 Codex (feasibility, complexity, APIs) |
| **Implementation** | 9 | 3 Claude (core code, tests, docs) + 3 Codex (implement, optimize, validate) + 3 Gemini (review, context, security) |
| **Verification** | 9 | 3 Claude (security, logic, edges) + 3 Gemini (context, patterns, regression) + 3 Codex (completeness, coverage, quality) |

**TOTAL PER TASK: 21 agent invocations (7 per phase Ã— 3 phases)**

### Enforcement Checklist (Before Marking ANY Task Complete)
- [ ] **21 agents** were invoked across 3 phases (7 per phase)
- [ ] **9+ concurrent** agents ran simultaneously at peak
- [ ] All three AI models (Claude, Codex, Gemini) participated in EACH phase
- [ ] Implementation was verified by at least **2 non-implementing AIs**
- [ ] Security review completed by at least **2 AIs** from different models
- [ ] Todo was updated throughout the process with phase tracking

## MAXIMUM CAPABILITY STANDARDS (MANDATORY)

**NEVER use weaker models or configurations to save tokens. Maximum capability is required at all times.**

### 1. Gemini Maximum Capability (MANDATORY)
```bash
gemini -m pro -y "prompt"
# OR
gemini -m gemini-3-pro-preview --approval-mode yolo "prompt"
```
- **1M token context**: Full codebase analysis
- **Pro routing**: Always most capable model
- **High thinking**: Extended reasoning
- **No Downgrade Rule:** Never use `gemini-1.5-flash` or standard `gemini-pro` unless explicitly instructed for a trivial task.

### 2. Codex Maximum Capability (MANDATORY)
```bash
codex exec -m gpt-5.2-codex -c 'model_reasoning_effort="xhigh"' -s danger-full-access "task"
```
- **xhigh reasoning**: Maximum reasoning depth
- **400K context**: Large codebase understanding
- **Full access**: System-wide modifications
- **No Downgrade Rule:** Never use `gpt-4o` or lower reasoning settings for implementation tasks.

### 3. Claude Maximum Capability (MANDATORY)
- **Architecture/Security:** Use `ultrathink` (32K tokens)
- **Implementation:** Use standard `thinking` (4K-10K tokens)
- **Opus model**: Deepest analysis via Task tool with model="opus"
- **No Downgrade Rule:** Do not turn off thinking mode for code generation.

### Enforcement Checklist (Capability Verification)
- [ ] **Gemini:** Verified `-m pro` or `gemini-3-pro-preview` is used
- [ ] **Codex:** Verified `xhigh` reasoning is active
- [ ] **Claude:** Verified thinking mode is enabled
- [ ] **Context:** Verified full relevant context was loaded
- [ ] **Downgrade Check:** Confirmed no lower-tier models were selected

## TRI-AI ACTIVE TODO MANAGEMENT (CRITICAL)

Every AI (Claude, Codex, Gemini) MUST:
1. **Add new requirements** discovered during work
2. **Update task status** in real-time
3. **Break down complex tasks** into subtasks
4. **Flag blockers** and dependencies
5. **Record verification results**

## TRI-AI VERIFICATION WORKFLOW (MANDATORY)

### Pre-Work Planning Protocol (Zero-Assumption Rule)
**BEFORE starting ANY work, the following steps are MANDATORY:**

1. **Cross-AI Clarification (Zero-Assumption Rule):**
   - You MUST ask Gemini or Codex to explain the requirements back to you to ensure shared understanding.
   - *Command:* `gemini "Explain the core requirements and potential edge cases for: [task description]"`
   - *Command:* `codex exec "Analyze technical constraints for: [task description]"`

2. **Build Comprehensive TODO List:**
   - Build todo list **based on the AI explanations**, not just the user prompt
   - Include ALL tasks from analysis/plans
   - Include specific "Clarification" items if any ambiguity remains
   - Consider all 3 AIs (Claude, Codex, Gemini) for implementation

3. **User Approval Gate:**
   - Present the AI-verified understanding and todo list to the user
   - **STOP** and wait for approval before executing any code
   - If changes requested, update and re-present

### Verification Before Completion
**NO todo item is considered DONE until:**
1. **Implementation complete** by primary AI
2. **Verification by different AI** - Ask Gemini OR Codex to verify
3. **Both AIs agree** the task is correctly implemented
4. **Update todo status** only after verification passes

### Verification Commands
```bash
# Ask Gemini to verify
gemini -y "Verify this implementation is correct: [description]. Check for: correctness, security, edge cases. Report PASS/FAIL with reasons."

# Ask Codex to verify
codex exec -m gpt-5.2-codex "Verify this implementation: [description]. Check: logic, security, completeness. Report PASS/FAIL."
```

### Todo Building Rules
- **Never start work** with incomplete todo list
- **Break down** complex tasks into verifiable subtasks
- **Assign AI** to each task (Claude/Codex/Gemini)
- **Assign verifier** to each task (different AI than implementer)
- **Track status**: pending â†’ in_progress â†’ verification â†’ completed

## STRICT TRI-AGENT WORKFLOW PROTOCOL (MANDATORY)

> **This protocol MUST be followed for EVERY task. No exceptions.**

### Todo-First Enforcement (BLOCKING)

**BEFORE starting ANY work, you MUST:**

1. **Build Complete TODO List**
   - Convert ENTIRE plan to granular tasks
   - NO work begins until TODO list is complete
   - Each task must have: ID, Description, Assigned AI, Verifier AI

2. **Cross-AI Clarification (MANDATORY)**
   ```bash
   # Ask BOTH Gemini and Codex to clarify requirements
   gemini -y "Explain what the user needs for: [requirement]. Clarify any ambiguities."
   codex exec "Interpret this requirement: [requirement]. List specific implementation steps."
   ```
   - Incorporate clarifications into TODO list
   - Do NOT skip this step

3. **User Approval Gate**
   - Present complete TODO list to user
   - Show AI assignments and verifiers
   - Get EXPLICIT approval before proceeding
   - If changes requested, update and re-present

### Multi-Agent Assignment (REQUIRED)

**ALL tasks must use the 3-AI ecosystem:**

| AI | Strengths | Assign For |
|----|-----------|------------|
| **Claude** | Architecture, orchestration, complex reasoning | Core logic, integration, security |
| **Codex** | Implementation, prototyping, validation | Scripts, tests, API work |
| **Gemini** | Large context, documentation, patterns | Codebase analysis, docs, reviews |

**Assignment Rules:**
- Every TODO must have `Assigned AI` + `Verifier AI`
- Verifier MUST be different from Assigned AI
- Distribute tasks across all 3 AIs (not all to one)

## TODO LIST FORMAT SPECIFICATION (MANDATORY)

### Required Table Structure

```markdown
| ID | Task | Assigned AI | Verifier AI | Status | Verified |
|----|------|:-----------:|:-----------:|:------:|:--------:|
| T1 | [Description] | Claude/Codex/Gemini | [Different AI] | [Status] | [ ] |
```

### Status Flow

```
Pending â†’ In Progress â†’ Ready for Verify â†’ Verified â†’ Completed
```

### Status Definitions

| Status | Meaning | Next Action |
|--------|---------|-------------|
| `Pending` | Not started | Begin work |
| `In Progress` | Work underway | Complete implementation |
| `Ready for Verify` | Implementation done | Request verification |
| `Verified` | Verification PASSED | Mark completed |
| `Blocked` | Cannot proceed | Resolve blocker |
| `Failed` | Verification FAILED | Fix and re-verify |

### Verification Checkbox Rules

- `[ ]` = Not verified
- `[x]` = Verified by assigned verifier
- `[!]` = Verification failed, needs rework

## USER APPROVAL GATE (MANDATORY)

### Before Work Begins

**NO implementation starts until user approves:**

1. **Present TODO List** with:
   - All tasks from plan/analysis
   - AI assignments for each task
   - Verifier assignments
   - Estimated complexity

2. **Ask for Approval** using AskUserQuestion tool

3. **If Modified:**
   - Update TODO list
   - Re-present for approval
   - Repeat until approved

### During Work

**Pause and get approval for:**
- Scope changes (new requirements discovered)
- Major approach changes
- Security-sensitive operations
- Budget-impacting decisions

## VERIFICATION PROTOCOL (TWO-KEY RULE) â€” Enhanced

**Purpose:** Any change must be independently verified by a second agent before acceptance.

**Verification request format (required):**
```
VERIFY:
- Scope: <files/paths>
- Change summary: <1â€“3 sentences>
- Expected behavior: <concrete outcomes>
- Repro steps: <commands or manual steps>
- Evidence to check: <logs/screenshots/tests>
- Risk notes: <edge cases>
```

**PASS/FAIL criteria:**
- **PASS** if *all* expected behaviors match, tests/steps reproduce cleanly, and no regressions.
- **FAIL** if any expected behavior is missing, tests/steps fail, or regressions/new risks appear.
- **INCONCLUSIVE** is not allowed; verifier must choose PASS or FAIL.

**Re-verification rules:**
- Any change after a FAIL requires a **fresh** verification request.
- The verifier must re-run the **full** scope (no partial "spot checks").

## STALEMATE RESOLUTION PROTOCOL

**Trigger:** Implementer and verifier disagree after a verification cycle.

- **Max retries:** 2 total verification cycles after initial disagreement.
- **Deadlock detection:** If the same dispute recurs **twice**, declare a deadlock.
- **Tieâ€‘breaker escalation:** Escalate to the user with:
  - the disputed claim,
  - evidence from both sides,
  - a clear ask: "Which outcome should we prioritize?"
- **Alternative path:** Request consensus from a **third AI** and follow majority decision.
- **Documentation:** Record the deadlock and resolution path in the change log.

## ROLLBACK & RECOVERY PROCEDURES

**When to rollback:**
- Verification fails **3 times** on the same change.
- A **critical error** is introduced (data loss, security regression, prod outage risk).
- The change is no longer aligned with user intent.

**How to rollback:**
- **Git reset** (if committed): `git reset --hard <last-good-commit>`
- **Checkpoint restore**: Restore to last known-good checkpoint.

**Postâ€‘rollback verification:**
- Re-run the **original** verification steps against the rolled-back state.
- Log the rollback reason and verification outcome.

**Preventing rollback loops:**
- Require a **new plan** before re-attempting the same change.
- If rollback happens twice, **escalate to user** for direction.

## PROGRESS REPORTING CADENCE & FORMAT

**Reporting Frequency:**
- **Routine Updates:** Every 30 minutes or after completing a major todo item.
- **Exception Updates:** IMMEDIATELY upon encountering an error or blocker.

**Required Metrics:**
1. **Status:** (On Track / At Risk / Blocked)
2. **Completion %:** Estimated percentage of current task.
3. **Token Usage:** Current session token count.
4. **Next Milestone:** Time/Goal for the next checkpoint.

**Blocker Escalation:**
- If a task takes >15 mins longer than expected: **REPORT**.
- If an error persists after 1 retry: **REPORT**.
- If tool output is ambiguous: **ASK FOR CLARIFICATION**.

**Status Template:**
```markdown
**STATUS UPDATE: [Timestamp]**
- **Current Task:** [Task ID/Name]
- **Status:** [ðŸŸ¢ On Track / ðŸŸ¡ At Risk / ðŸ”´ Blocked]
- **Progress:** [XX]% complete
- **Recent Action:** [One sentence summary]
- **Next Step:** [Immediate next action]
- **Issues:** [None / Description of blocker]
```

## 24-HOUR CONTINUOUS OPERATION (CRITICAL)

### Session Persistence Architecture

**Progress File Pattern** (Required for context resumption):
```bash
# Create/update claude-progress.txt at start of each session
cat > claude-progress.txt <<EOF
# Session Progress Log
## Last Updated: $(date -Iseconds)
## Session ID: ${SESSION_ID}

### Completed Tasks:
$(git log --oneline -20)

### Current State:
- Active branch: $(git branch --show-current)
- Uncommitted changes: $(git status --short | wc -l)
- Last checkpoint: ${LAST_CHECKPOINT}

### Next Actions:
[TODO items from previous session]
EOF
```

**State Persistence Locations:**
| State Type | Location | Backup Frequency |
|------------|----------|------------------|
| Task Queue | `state/tri-agent.db` (SQLite) | Real-time WAL |
| Progress Log | `claude-progress.txt` | Every commit |
| Checkpoints | `sessions/checkpoints/` | Every 5 minutes |
| Event Log | `state/event-store/events.jsonl` | Append-only |

### Context Window Management (CRITICAL FOR 24HR)

**Token Budget Per Session:**
| Model | Context Window | Safe Working Limit | Refresh Trigger |
|-------|---------------|-------------------|-----------------|
| Claude Opus/Sonnet | 200K | 160K (80%) | 150K tokens used |
| Gemini 3 Pro | 1M | 800K (80%) | 750K tokens used |
| Codex GPT-5.2 | 400K | 320K (80%) | 300K tokens used |

**Context Overflow Prevention:**
```bash
check_context_health() {
    local tokens_used=$1 model=$2
    case "$model" in
        claude*) limit=150000 ;;
        gemini*) limit=750000 ;;
        codex*)  limit=300000 ;;
    esac
    if [[ $tokens_used -gt $limit ]]; then
        create_session_checkpoint
        gemini -y "Summarize session state: $(cat claude-progress.txt)"
        refresh_session
    fi
}
```

**Model Failover Chain:**
```
Claude Sonnet (200K) â†’ Gemini Pro (1M) â†’ Split into sub-tasks
```

### Session Refresh Protocol (Every 8 Hours)

```bash
SESSION_DURATION_HOURS=8
SESSION_REFRESH_ENABLED=true
CONTEXT_CHECKPOINT_INTERVAL=300  # 5 minutes

# At session boundary:
# 1. Checkpoint all in-progress work
# 2. Commit with descriptive message
# 3. Update claude-progress.txt
# 4. Generate session summary via Gemini
# 5. Clear context and reload essentials
# 6. Resume from checkpoint
```

### Watchdog & Auto-Recovery Stack

**3-Layer Supervision:**
```
Layer 1: tri-agent-daemon (Parent)
  â”œâ”€ tri-agent-worker (Task executor)
  â”œâ”€ tri-agent-supervisor (Approval flow)
  â””â”€ budget-watchdog (Cost tracking)

Layer 2: watchdog-master (External supervisor)
  â”œâ”€ Monitors Layer 1 health
  â”œâ”€ Restarts failed daemons
  â””â”€ Exponential backoff (2^n seconds)

Layer 3: tri-24-monitor (24-hour guardian)
  â”œâ”€ Heartbeat every 30 seconds
  â”œâ”€ System health checks
  â””â”€ Alerting on failures
```

**Recovery Hierarchy:**
| Failure Type | Detection | Recovery Action |
|--------------|-----------|-----------------|
| Task Timeout | Heartbeat > threshold | Requeue task, increment retry |
| Worker Crash | PID check fails | Mark dead, recover tasks |
| Daemon Crash | watchdog-master | Auto-restart with backoff |
| Context Overflow | Token tracking | Session refresh |
| Rate Limit | 429 response | Exponential backoff |
| Budget Exhausted | cost-tracker | Pause until reset |

### 24-Hour Budget Management

**Daily Token Budgets:**
| Model | Daily Limit | Hourly Average | Alert Threshold |
|-------|-------------|----------------|-----------------|
| Claude Max | ~100M tokens | 4.2M/hour | 80% daily |
| Gemini Pro | Unlimited* | N/A | API rate limits |
| Codex | ~50M tokens | 2.1M/hour | 80% daily |

**Budget Reset Schedule:**
- Claude: Rolling 5-hour window + 7-day weekly cap
- Gemini: Daily reset at midnight UTC
- Codex: Daily reset at midnight UTC

### 24-Hour Operation Checklist

**Before Starting:**
- [ ] Verify watchdog-master is running
- [ ] Check daily budget availability
- [ ] Initialize claude-progress.txt
- [ ] Create initial git checkpoint
- [ ] Configure 8-hour session refresh

**During Operation (Automated):**
- [ ] Heartbeat every 30 seconds
- [ ] Context checkpoint every 5 minutes
- [ ] Progress update every commit
- [ ] Budget check every 100K tokens
- [ ] Session refresh at 8-hour boundaries

**Recovery Triggers:**
- [ ] Task timeout â†’ Requeue
- [ ] Worker crash â†’ Auto-restart
- [ ] Context overflow â†’ Session refresh
- [ ] Budget exhaustion â†’ Pause & alert

### Commands for 24-Hour Operation

```bash
# Start 24-hour session
tri-agent start --mode=24hr --watchdog --monitor

# Check session health
tri-agent health --verbose

# Force checkpoint
tri-agent checkpoint --reason="manual"

# Resume from crash
tri-agent resume --from-checkpoint latest

# View progress
cat claude-progress.txt

# Check budget
cost-tracker --status --daily

# Session refresh
tri-agent session-refresh --summarize
```

### Resource & Log Governance (24HR MANDATORY)

**Log Rotation Policy:**
- **Max Log Size:** 50MB per file
- **Retention:** 7 days (rolling window)
- **Rotation Check:** Every session refresh (8 hours)
- **Command:** `find logs/ -name "*.log" -size +50M -exec gzip {} \;`

**Hardware Safety Limits:**
- **Max Concurrent CLI Processes:** 15 (prevent fork bombs)
- **Max RAM Usage:** 75% of System Total (pause new agents if exceeded)
- **Disk Free Space Floor:** 2GB (emergency stop if crossed)

**Emergency Dead Man's Switch:**
- **Mechanism:** `tri-24-monitor` must touch `~/.claude/heartbeat` every 60s
- **Systemd/Cron Action:** If file age > 5m, kill all `tri-agent` processes and restart `watchdog-master`

### Large Repository Protocol (8GB+ Support)

**Context Strategy: Sparse Loading**
- **Problem:** 1M tokens â‰ˆ 4MB text. 8GB repo is 2000x larger
- **Solution:** NEVER load "entire codebase". Use hierarchical narrowing:
  1. **Map:** `tree -L 2` or `find . -maxdepth 2` for structure
  2. **Search:** Use `ripgrep` (rg) to find specific symbols
  3. **Read:** Only read files confirmed relevant by search

**Smart Ignore (Performance):**
```bash
# .geminiignore / .claudeignore
package-lock.json
yarn.lock
*.log
.cache/
tmp/
dist/
build/
node_modules/
*.so
*.dll
*.png
*.mp4
```

**Incremental Verification (8GB+ repos):**
- **Unit:** `jest -o` / `pytest --changed-files` (changed only)
- **Build:** `tsc --incremental`
- **Lint:** `eslint --cache`

### Security Hardening (Production)

**Risk Mitigation:**
| Risk | Mitigation |
|------|------------|
| `danger-full-access` | Run Codex in Docker container |
| YOLO mode | Audit log all auto-approved actions |
| Credential exposure | Secret scanning on `claude-progress.txt` |
| Budget drain | Hard stop at 95% daily budget |

**Atomic State Writes:**
```bash
# Use write-to-temp-and-rename pattern
write_state() {
    local target="$1" content="$2"
    local tmp="${target}.tmp.$$"
    echo "$content" > "$tmp"
    mv "$tmp" "$target"  # Atomic on same filesystem
}
```

**Fallback Summarization:**
- If Gemini fails during session refresh, dump raw context to timestamped file
- Alert and preserve data for manual recovery

## Multi-Model Routing

| Task Type               | Primary Model   | When to Use                                           |
| ----------------------- | --------------- | ----------------------------------------------------- |
| Architecture & Design   | Claude Opus     | Deep reasoning, complex decisions                     |
| Implementation          | Claude Sonnet   | Standard coding, speed + quality                      |
| Rapid Prototyping       | Codex CLI       | Fast iteration, alternatives                          |
| Large Codebase Analysis | Gemini          | Context > 100K tokens                                 |
| Complex Debugging       | o3-pro          | Extended reasoning chains                             |
| Documentation           | Gemini          | Long-form writing                                     |
| Code Review             | Claude Sonnet   | Balanced analysis                                     |
| Security Audit          | Claude Opus     | Thorough vulnerability analysis                       |
| Ultra Architecture      | Claude Opus Max | `/agents/ai-ml/claude-opus-max` - ultrathink 32K      |
| Project Refactoring     | Codex Max       | `/agents/ai-ml/codex-max` - xhigh reasoning           |
| Full Codebase Analysis  | Gemini Deep     | `/agents/ai-ml/gemini-deep` - gemini-3-pro 1M context |

## Thinking Mode Escalation

- Standard: `think` (4K tokens) - Simple tasks
- Extended: `think hard` (10K tokens) - Complex logic
- Maximum: `ultrathink` (32K tokens) - Architecture, debugging

## Slash Commands

### SDLC Phase Commands

- `/sdlc:brainstorm [feature]` - Phase 1: Requirements
- `/sdlc:spec [feature]` - Phase 2: Documentation
- `/sdlc:plan [feature]` - Phase 3: Technical design
- `/sdlc:execute [feature] [mission]` - Phase 4: Implementation
- `/sdlc:status` - Phase 5: Progress tracking

### AB Method Commands

- `/create-task [desc]` - Define new task with specs
- `/create-mission` - Break task into focused missions
- `/resume-mission` - Continue incomplete mission
- `/test-mission` - Generate tests for mission
- `/ab-master` - Orchestrate workflow

### Utility Commands

- `/feature [desc]` - Full feature workflow (all phases)
- `/bugfix [desc]` - Bug fix with root cause analysis
- `/debug [issue]` - Debug assistance with root cause analysis
- `/test [target]` - Generate comprehensive tests
- `/review [target]` - Multi-agent code review
- `/security-review [target]` - OWASP vulnerability scan
- `/codex [task]` - Execute via Codex CLI
- `/gemini [task]` - Execute via Gemini CLI (1M context)
- `/consensus [task]` - Tri-agent consensus (Claude + Codex + Gemini)
- `/route [type] [task]` - Route to optimal model
- `/context-prime` - Load project context

### Git Commands

- `/git/branch [name]` - Create and manage branches
- `/git/commit [message]` - Create commits with quality gates
- `/git/pr [title]` - Create pull requests
- `/git/sync` - Sync with remote branches

## GITHUB ISSUE WORKFLOW (TRI-AGENT MANDATORY)

### Issue Lifecycle
```
OPEN â†’ ASSIGNED â†’ IN_PROGRESS â†’ REVIEW_1 â†’ REVIEW_2 â†’ CLOSED
                       â†‘______________|  (if FAIL)
```

### Enforcement Rules (BLOCKING)
1. **3 Different AI Models Required**: Implementer â‰  Reviewer1 â‰  Reviewer2
2. **Cannot Close Without 2 Approvals** from different models
3. **All Comments Signed**: Ahmed Adel Bakr Alderai (no AI attribution)
4. **Status Updates Every 30 Minutes** during active work

### Agent Assignment by Issue Type
| Category | Implementer | Reviewer 1 | Reviewer 2 |
|----------|-------------|------------|------------|
| Security | Claude | Codex | Gemini |
| UI/Frontend | Codex | Claude | Gemini |
| Documentation | Gemini | Claude | Codex |
| Complex Logic | Claude | Gemini | Codex |
| Testing | Codex | Gemini | Claude |
| API/Backend | Codex | Claude | Gemini |

### GitHub Issue Commands
- `/github/issue/assign #N` - Assign with tri-agent commitment
- `/github/issue/complete #N` - Request review (post VERIFY block)
- `/github/issue/review #N PASS|FAIL` - Submit review decision
- `/github/issue/close #N` - Close (requires 2 approvals from different AIs)

### Comment Templates
See: `.claude/docs/issue-templates.md`

### Integration
- Uses existing VERIFY block format (see Two-Key Rule)
- Uses TODO-First Protocol for implementation planning
- Follows Attribution Rules (Ahmed Adel Bakr Alderai only)

### Command Aliases

- `/document` â†’ `/sdlc:spec` - Create documentation
- `/execute` â†’ `/sdlc:execute` - Execute implementation
- `/track` â†’ `/sdlc:status` - Track progress

## Commit Format (Tri-Agent)

```
type(scope): description

Body explaining what and why

Tri-Agent Approval:
- Claude (Sonnet): APPROVE
- Codex (GPT-5.2): APPROVE
- Gemini (3 Pro): APPROVE

Author: Ahmed Adel Bakr Alderai
```

## MCP Servers

- **git**: Version control operations
- **github**: Issues, PRs, repos via API
- **postgres**: Database queries and schema
- **filesystem**: File system access

## CLI Tool Usage (CRITICAL)

### Gemini CLI

```bash
# Basic usage - both work
gemini "your prompt here"             # Positional argument
gemini -p "your prompt here"          # -p flag (still works)

# With auto-approve (YOLO mode)
gemini -y "prompt"                    # Auto-approve all tools
gemini --approval-mode yolo "prompt"  # Same as -y

# Gemini 3 Pro (requires Preview Features enabled)
gemini -m gemini-3-pro-preview "prompt"  # Correct model ID
gemini -m pro "prompt"                    # Shorthand for pro model (auto-routes)

# Combined flags
gemini -m pro -y "prompt"                          # Pro model + auto-approve
gemini -m gemini-3-pro-preview --approval-mode yolo "prompt"  # Explicit model + YOLO

# Resume previous session
gemini -r latest                      # Resume most recent session
gemini --resume 5                     # Resume session by index
gemini --list-sessions                # List available sessions
```

### Gemini Configuration File (~/.gemini/settings.json)

```json
{
  "security": {
    "auth": {
      "selectedType": "oauth-personal"
    }
  },
  "tools": {
    "sandbox": false
  },
  "previewFeatures": true,
  "general": {
    "previewFeatures": true,
    "preferredModel": "gemini-3-pro-preview"
  },
  "routing": {
    "preferPro": true
  },
  "thinking": {
    "level": "high"
  }
}
```

### Gemini 3 Pro Setup & Usage

**Requirements**:

- Gemini CLI v0.18.x+ (`npm install -g @google/gemini-cli@latest`)
- Google AI Pro/Ultra subscription OR paid Gemini API key
- Preview Features enabled

**Enable Gemini 3 Pro**:

1. Run `gemini` interactively
2. Type `/settings` â†’ Enable "Preview Features"
3. Type `/model` â†’ Select "Pro routing" for Gemini 3 Pro priority
4. Model shows as "Pro (gemini-3-pro, gemini-2.5-pro)"

**Model Routing**:

- **Auto routing** (default): Simple â†’ 2.5 Flash, Complex â†’ 3 Pro or 2.5 Pro
- **Pro routing**: Always uses most capable model (Gemini 3 Pro when enabled)

**Usage Limits**:

- Daily limits apply; CLI notifies when reached
- Options: Switch to 2.5 Pro, upgrade, or wait for reset
- Quota resets shown in error message (e.g., "resets after 4h")

**Best Use Cases for Gemini 3 Pro**:

- Full codebase analysis (1M token context)
- Complex multi-step reasoning
- Multimodal tasks (images, PDFs, code repos)
- Agentic coding with project scaffolding
- Documentation generation from code

### Gemini Native Sessions (Multi-turn Conversations)

The CLI natively supports conversation history - no manual context management needed:

```bash
# Start a new conversation
gemini "Analyze the database schema"

# Follow up on the same context (resumes latest session)
gemini -r latest "Now generate migration scripts based on your analysis"

# List available sessions
gemini --list-sessions

# Resume a specific older session by index
gemini --resume 5 "Continue with the refactoring we discussed"

# Delete old sessions
gemini --delete-session 3
```

**Tip:** Use `-r latest` to maintain context across multiple commands without re-explaining the task.

### Gemini Authentication

**Account:** Configured via `~/.gemini/oauth_creds.json` (Personal OAuth)

**Auth Type:** `oauth-personal` - No GOOGLE_CLOUD_PROJECT required

```bash
# Check account status
gemini-switch

# If GOOGLE_CLOUD_PROJECT error occurs, unset it:
unset GOOGLE_CLOUD_PROJECT
```

**Credentials Location:** `~/.gemini/oauth_creds.json`

### Codex CLI (GPT-5.2)

```bash
# Non-interactive execution
codex exec "task description"
codex exec "Implement feature X" src/component.py

# With specific model
codex exec -m o3 "complex reasoning task"

# MAXIMUM CONFIGURATION - GPT-5.2-Codex with xhigh reasoning
codex exec -m gpt-5.2-codex -c 'model_reasoning_effort="xhigh"' -s danger-full-access "task"

# View help
codex --help
codex exec --help
```

### Codex Configuration File (~/.codex/config.toml)

```toml
model = "gpt-5.2-codex"
model_provider = "openai"
model_context_window = 400000
model_max_output_tokens = 128000
model_reasoning_effort = "xhigh"    # Options: none, minimal, low, medium, high, xhigh
approval_policy = "never"
sandbox_mode = "workspace-write"   # Or "danger-full-access" for full system access
```

### Tri-Agent CLI Pattern

```bash
# 1. Claude (primary orchestration) - Direct in Claude Code
# 2. Codex (implementation)
codex exec "Review and implement: <task>"

# 3. Gemini (validation/security)
gemini -y "Review for security issues: <code>"
```

## Code Style

- TypeScript: Strict mode, explicit types
- Python: Type hints, async/await for I/O
- Formatting: Prettier (JS/TS), Black (Python)
- Linting: ESLint, Ruff
- Commits: Conventional commits

## Alerting & Notification (P3.2)

### Alert Levels and Routing

| Level | Response Time | Notification Method | Example Triggers |
|-------|--------------|---------------------|------------------|
| **CRITICAL** | Immediate | Desktop + Sound + Log | Daemon crash, security breach, budget exhausted |
| **ERROR** | < 5 min | Desktop + Log | Task failure, API error, rate limit |
| **WARNING** | < 15 min | Log only | High memory, slow response, context near limit |
| **INFO** | Batched hourly | Log only | Task completed, checkpoint created |

### Notification Hooks

```bash
# Desktop notification (requires libnotify)
notify-send -u critical "Tri-Agent CRITICAL" "Daemon crashed: $REASON"

# Slack webhook (optional)
curl -X POST "$SLACK_WEBHOOK_URL" \
  -H 'Content-Type: application/json' \
  -d '{"text":"CRITICAL: '"$MESSAGE"'"}'

# Email via msmtp (optional)
echo "Subject: Tri-Agent Alert\n\n$MESSAGE" | msmtp "$ALERT_EMAIL"
```

### Alert Configuration

```bash
# ~/.claude/alerts.conf
ALERT_LEVEL_THRESHOLD="warning"  # minimum level to log
DESKTOP_NOTIFY_ENABLED=true
SLACK_WEBHOOK_URL=""             # optional
ALERT_EMAIL=""                   # optional
SOUND_ENABLED=true               # play sound for critical
```

## Metrics & Observability (P3.3)

### Key Performance Indicators (KPIs)

| Metric | Target | Alert Threshold | Collection Method |
|--------|--------|-----------------|-------------------|
| Task Success Rate | > 95% | < 90% | `tasks.completed / tasks.total` |
| Avg Task Duration | < 5 min | > 10 min | `avg(task.end - task.start)` |
| Agent Utilization | > 70% | < 50% | `active_agents / max_agents` |
| Context Usage | < 80% | > 90% | `tokens_used / context_limit` |
| Error Rate | < 5% | > 10% | `errors / total_operations` |
| Lock Contention | < 10% | > 20% | `lock_failures / lock_attempts` |

### Metrics Collection

```bash
# Prometheus-style metrics endpoint
# Location: ~/.claude/metrics/current.prom

# Metric format:
tri_agent_tasks_total{status="completed"} 1234
tri_agent_tasks_total{status="failed"} 56
tri_agent_active_agents 9
tri_agent_context_tokens_used 145000
tri_agent_session_duration_seconds 3600
```

### Dashboard Commands

```bash
# Real-time stats
tri-agent stats --live

# Historical metrics
tri-agent metrics --range 24h --format json

# Export for Grafana
tri-agent metrics --export prometheus > metrics.prom
```

### OpenTelemetry Integration (Optional)

```bash
# Enable OTEL export
export OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4317"
export OTEL_SERVICE_NAME="tri-agent"
tri-agent start --telemetry
```

## Graceful Degradation Policy (P3.4)

### Failure Response Hierarchy

```
Level 1: Retry with backoff (3 attempts, 2^n seconds)
    â†“ (if still failing)
Level 2: Failover to alternate model
    â†“ (if unavailable)
Level 3: Queue for later retry
    â†“ (if queue full or critical)
Level 4: Notify and pause
```

### Model Failover Chain

| Primary | Failover 1 | Failover 2 | Last Resort |
|---------|-----------|------------|-------------|
| Claude Opus | Claude Sonnet | Gemini Pro | Queue + Notify |
| Gemini 3 Pro | Gemini 2.5 Pro | Claude Sonnet | Queue + Notify |
| Codex GPT-5.2 | Codex o3 | Claude Sonnet | Queue + Notify |

### Circuit Breaker States

```
CLOSED (normal) â†’ 5 failures â†’ OPEN (blocking)
                                    â†“ 60 seconds
                              HALF-OPEN (testing)
                                    â†“ success
                              CLOSED (normal)
```

### Degradation Configuration

```bash
# ~/.claude/degradation.conf
MAX_RETRIES=3
RETRY_BACKOFF_BASE=2
CIRCUIT_BREAKER_THRESHOLD=5
CIRCUIT_BREAKER_TIMEOUT=60
QUEUE_MAX_SIZE=100
FAILOVER_ENABLED=true
```

### Degraded Mode Operations

When in degraded mode:
- [ ] Reduce concurrent agents to minimum (3)
- [ ] Disable non-essential MCP servers
- [ ] Extend timeout thresholds 2x
- [ ] Queue low-priority tasks
- [ ] Log all operations for post-incident review

## Data Retention & Cleanup (P3.5)

### Retention Policies

| Data Type | Retention Period | Cleanup Frequency | Location |
|-----------|-----------------|-------------------|----------|
| Audit Logs | 30 days | Daily | `~/.claude/logs/audit/` |
| Session Logs | 7 days | Daily | `~/.claude/logs/sessions.log` |
| Checkpoints | 3 days | Every 8 hours | `~/.claude/sessions/checkpoints/` |
| Snapshots | 7 days | Daily | `~/.claude/sessions/snapshots/` |
| Task Files | 14 days | Daily | `~/.claude/tasks/` |
| Metrics | 90 days | Weekly | `~/.claude/metrics/` |
| Backups | 30 days | Daily | `~/.claude/backups/` |

### Automated Cleanup Script

```bash
#!/bin/bash
# ~/.claude/scripts/cleanup.sh
# Run via cron: 0 3 * * * ~/.claude/scripts/cleanup.sh

LOG_DIR="${HOME}/.claude/logs"
SESSION_DIR="${HOME}/.claude/sessions"

# Rotate logs > 50MB
find "$LOG_DIR" -name "*.log" -size +50M -exec gzip {} \;

# Delete old audit logs
find "$LOG_DIR/audit" -name "*.jsonl" -mtime +30 -delete
find "$LOG_DIR/audit" -name "*.jsonl.gz" -mtime +90 -delete

# Delete old checkpoints
find "$SESSION_DIR/checkpoints" -name "*.json" -mtime +3 -delete

# Delete old snapshots
find "$SESSION_DIR/snapshots" -name "*.json" -mtime +7 -delete

# Vacuum SQLite databases
for db in "${HOME}/.claude/state"/*.db; do
    sqlite3 "$db" "VACUUM; PRAGMA wal_checkpoint(TRUNCATE);"
done

# Report disk usage
du -sh "${HOME}/.claude" >> "$LOG_DIR/disk-usage.log"
```

### Disk Space Alerts

```bash
# Minimum free space thresholds
DISK_WARN_THRESHOLD_GB=5     # Warning if < 5GB free
DISK_CRITICAL_THRESHOLD_GB=2 # Emergency stop if < 2GB free
```

## Incident Response

**Full runbooks:** See `.claude/docs/incident-runbooks.md`

| Runbook | Severity | Trigger |
|---------|----------|---------|
| Daemon Crash | CRITICAL | PID stale, no heartbeat |
| Context Overflow | HIGH | Token limit exceeded |
| Budget Exhaustion | MEDIUM | 429 errors |
| Lock Contention | MEDIUM | High lock failures |
| Security Incident | CRITICAL | Suspicious activity |

**Escalation:** CRITICALâ†’5min, HIGHâ†’15min, MEDIUMâ†’1hr, LOWâ†’24hr

## TODO-FIRST PROTOCOL (BLOCKING REQUIREMENT)

**This protocol MUST be followed for EVERY task. NO EXCEPTIONS.**

### Phase 1: Cross-AI Requirements Clarification (MANDATORY)

**BEFORE building any TODO list, you MUST:**

1. **Ask Gemini to explain requirements:**
   ```bash
   gemini -m pro -y "Explain in detail what the user needs for: [task]. List all requirements, edge cases, and potential challenges."
   ```

2. **Ask Codex to analyze implementation steps:**
   ```bash
   codex exec -m gpt-5.2-codex "Analyze the requirements for: [task]. List specific implementation steps, dependencies, and technical considerations."
   ```

3. **Synthesize both perspectives** into a unified understanding before building TODO

### Phase 2: Build Complete TODO List (BEFORE ANY WORK)

**CRITICAL: NO work starts until TODO is 100% complete**

1. **Extract EVERY task** from all plans, research, and AI clarifications
2. **Break down complex tasks** into granular, verifiable subtasks
3. **Assign ALL 3 AIs** to implementation:
   - Distribute tasks across Claude, Codex, and Gemini
   - NO single AI should do all the work
4. **Assign different AI as verifier** for each task:
   - Verifier MUST be different from implementer
   - Record verifier in TODO table

### Phase 3: User Approval Gate (BLOCKING)

**STOP and wait for explicit user approval:**

1. Present the complete TODO list
2. Explain scope, approach, and AI assignments
3. **DO NOT proceed without "approved" or similar confirmation**
4. If changes requested, update TODO and re-present

### Phase 4: Implementation with Verification

**NO task is considered DONE until:**

1. Implementation completed by assigned AI
2. **Verification by DIFFERENT AI** (Gemini or Codex must verify Claude's work, etc.)
3. Verification result recorded (PASS/FAIL)
4. Only then update status to "completed"

### Verification Commands (Use These)

```bash
# Gemini verifies implementation
gemini -m pro -y "Verify this implementation is correct: [description]. Check for: correctness, security, edge cases. Report PASS/FAIL with reasons."

# Codex verifies implementation
codex exec -m gpt-5.2-codex "Verify this implementation: [description]. Check: logic, security, completeness. Report PASS/FAIL."
```

### TODO Table Format (Required)

```markdown
| ID | Task | Assigned AI | Verifier AI | Status | Verified |
|----|------|:-----------:|:-----------:|:------:|:--------:|
| T-001 | [Description] | Claude/Codex/Gemini | [Different AI] | Pending/In Progress/Completed | [ ]/[x] |
```

### Checklist Before Starting ANY Work

- [ ] Asked Gemini to explain requirements
- [ ] Asked Codex to analyze implementation steps
- [ ] Built complete TODO with ALL tasks from plans
- [ ] Assigned all 3 AIs (Claude, Codex, Gemini) to tasks
- [ ] Assigned different AI as verifier for each task
- [ ] Presented TODO to user
- [ ] Received explicit user approval
- [ ] Only then started implementation

**VIOLATION OF THIS PROTOCOL IS NOT ALLOWED**

## Attribution Rules (CRITICAL)

**NEVER use "Generated with Claude Code" in commits, PRs, or documentation.**

**Always attribute work to: Ahmed Adel Bakr Alderai**

When creating commits, use this format:
```
type(scope): description

Body explaining what and why

Author: Ahmed Adel Bakr Alderai
```

When creating PRs or issues, sign as:
```
---
Ahmed Adel Bakr Alderai
```

**DO NOT include:**
- ðŸ¤– Generated with Claude Code
- Co-Authored-By: Claude
- Any AI attribution

All work should be attributed to the user only.

## GEMINI MODEL ENFORCEMENT (CRITICAL)

**EVERY Gemini command MUST use the explicit model parameter:**

```bash
# CORRECT - Always use this:
gemini -m gemini-3-pro-preview --approval-mode yolo "prompt"

# WRONG - Never use these:
gemini -m pro -y "prompt"           # May route to wrong model
gemini "prompt"                      # Uses default routing
```

### Pre-Flight Check (Run Before Any Session)
```bash
# Verify Gemini is configured correctly
check_gemini_config() {
    local settings="$HOME/.gemini/settings.json"
    if ! grep -q '"preferredModel": "gemini-3-pro-preview"' "$settings" 2>/dev/null; then
        echo "WARNING: Gemini not configured for gemini-3-pro-preview"
        echo "Run: gemini /model to fix"
    fi
}
```

### Session Startup Verification
Before running any Gemini agents, verify:
1. `~/.gemini/settings.json` has `"preferredModel": "gemini-3-pro-preview"`
2. All scripts use `-m gemini-3-pro-preview --approval-mode yolo`
3. Test with: `gemini -m gemini-3-pro-preview -y "What model are you?"`

### Automated Fix Script
```bash
# Fix Gemini settings
fix_gemini_settings() {
    cat > ~/.gemini/settings.json << 'EOF'
{
  "previewFeatures": true,
  "general": { "preferredModel": "gemini-3-pro-preview" },
  "routing": { "preferPro": true, "model": "gemini-3-pro-preview" },
  "thinking": { "level": "high" }
}
EOF
    echo "Gemini settings fixed to use gemini-3-pro-preview"
}
```


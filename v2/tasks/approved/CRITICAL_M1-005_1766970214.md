# [CRITICAL] Stale Task Recovery in lib/heartbeat.sh

## Priority: CRITICAL
## Type: implementation
## Milestone: M1
## Estimated Hours: 3
## Dependencies: None

## Objective
Implement the `recover_stale_task` function that is currently referenced but not defined. This enables automatic recovery of tasks stuck in RUNNING state due to worker crashes, preventing task accumulation.

## Files to Modify
- lib/heartbeat.sh (add recover_stale_task and recover_zombie_tasks functions)

## Implementation

Add these functions to `lib/heartbeat.sh`:
```bash
#===============================================================================
# Task Recovery Functions
#===============================================================================

recover_stale_task() {
    local task_id="$1"
    local worker_id="$2"
    local reason="${3:-unknown}"

    log_warn "[RECOVERY] Recovering stale task: $task_id (worker: $worker_id, reason: $reason)"

    local running_dir="${AUTONOMOUS_ROOT}/tasks/running"
    local queue_dir="${AUTONOMOUS_ROOT}/tasks/queue"
    local task_file="${running_dir}/${task_id}"

    # Find task file if not exact match
    if [[ ! -f "$task_file" ]]; then
        task_file=$(find "$running_dir" -name "*${task_id}*" -type f 2>/dev/null | head -1)
    fi

    if [[ -n "$task_file" && -f "$task_file" ]]; then
        local task_name=$(basename "$task_file")
        local lock_file="${running_dir}/${task_name}.lock"
        local lock_dir="${running_dir}/${task_name}.lock.d"

        # Release locks
        rm -f "$lock_file" 2>/dev/null || true
        rmdir "$lock_dir" 2>/dev/null || true

        # Move back to queue
        mv "$task_file" "$queue_dir/" 2>/dev/null || {
            log_error "[RECOVERY] Failed to requeue task: $task_name"
            return 1
        }
        log_info "[RECOVERY] Task requeued: $task_name"
    fi

    # Update SQLite state
    if command -v sqlite3 &>/dev/null && [[ -f "$STATE_DB" ]]; then
        sqlite3 "$STATE_DB" <<SQL
UPDATE tasks
SET state='QUEUED', worker_id=NULL, updated_at=datetime('now'),
    recovery_count = COALESCE(recovery_count, 0) + 1
WHERE id='${task_id//\'/\'\'}';

UPDATE workers SET status='stale', last_heartbeat=datetime('now')
WHERE worker_id='${worker_id//\'/\'\'}';

INSERT INTO events (task_id, event_type, event_data, created_at)
VALUES ('${task_id//\'/\'\'}', 'TASK_RECOVERED', '{"reason": "${reason//\'/\'\'}"}', datetime('now'));
SQL
    fi

    # Log to ledger
    local ledger_file="${AUTONOMOUS_ROOT}/logs/ledger.jsonl"
    mkdir -p "$(dirname "$ledger_file")"
    echo "{\"timestamp\":\"$(date -Iseconds)\",\"event\":\"TASK_RECOVERED\",\"task\":\"$task_id\",\"worker\":\"$worker_id\",\"reason\":\"$reason\"}" >> "$ledger_file"

    return 0
}

# Batch recovery of zombie tasks in SQLite
recover_zombie_tasks() {
    local timeout_minutes="${1:-60}"

    log_info "[RECOVERY] Scanning for zombie tasks (timeout: ${timeout_minutes}m)"

    if command -v sqlite3 &>/dev/null && [[ -f "$STATE_DB" ]]; then
        local recovered
        recovered=$(sqlite3 "$STATE_DB" <<SQL
UPDATE tasks
SET state='QUEUED', worker_id=NULL, updated_at=datetime('now')
WHERE state='RUNNING'
  AND worker_id IN (
      SELECT worker_id FROM workers
      WHERE last_heartbeat < datetime('now', '-$timeout_minutes minutes')
  );
SELECT changes();
SQL
)
        log_info "[RECOVERY] Recovered $recovered zombie tasks"

        # Mark dead workers
        sqlite3 "$STATE_DB" <<SQL
UPDATE workers SET status='dead'
WHERE last_heartbeat < datetime('now', '-$timeout_minutes minutes')
  AND status != 'dead';
SQL
    fi
}

export -f recover_stale_task recover_zombie_tasks
```

## Acceptance Criteria
- [ ] `recover_stale_task` function defined and exported
- [ ] Task file moved from running/ back to queue/
- [ ] Lock files (both .lock and .lock.d) removed
- [ ] SQLite task state updated to QUEUED
- [ ] SQLite worker marked as stale
- [ ] Event logged to events table
- [ ] `recover_zombie_tasks` batch recovery works
- [ ] Recovery count incremented for tracking

## Verification
```bash
# Create a stale task scenario
mkdir -p tasks/running tasks/queue
echo "# Stale Test" > tasks/running/HIGH_stale_task.md
mkdir tasks/running/HIGH_stale_task.md.lock.d

# Source and run recovery
source lib/heartbeat.sh
recover_stale_task "HIGH_stale_task.md" "dead-worker-001" "manual test"

# Verify task requeued
ls tasks/queue/ | grep stale_task

# Verify lock removed
ls tasks/running/*.lock.d 2>/dev/null || echo "Locks cleaned"
```

## Created
- Time: 2025-12-29T01:03:34+00:00
- By: Claude
- Source: CLAUDE_MASTER_SYNTHESIS (FIX-5), CODEX_MASTER_SYNTHESIS (FIX-8)

#!/bin/bash
#===============================================================================
# claude-delegate - Wrapper for Claude CLI with JSON envelope output
#===============================================================================
# Wraps Claude CLI execution and outputs structured JSON response envelope.
# Features:
# - Circuit Breaker Integration
# - JSON Output
# - Cost Tracking
#===============================================================================

# Source common utilities
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/../lib"

if [[ -f "${LIB_DIR}/common.sh" ]]; then
    source "${LIB_DIR}/common.sh"
else
    echo '{"model":"claude","status":"error","decision":"ABSTAIN","confidence":0.0,"reasoning":"common.sh not found","output":"","trace_id":"unknown","duration_ms":0}'
    exit 1
fi

# Source Circuit Breaker
if [[ -f "${LIB_DIR}/circuit-breaker.sh" ]]; then
    source "${LIB_DIR}/circuit-breaker.sh"
fi

COMPONENT="CLAUDE"
export COMPONENT
TRACE_ID="${TRACE_ID:-claude-$(date +%Y%m%d%H%M%S)-$$}"
export TRACE_ID

# Config
DEFAULT_TIMEOUT=300
CLAUDE_CMD="${CLAUDE_CMD:-claude}"

# JSON Output Helper
json_output() {
    local status="$1"
    local decision="$2"
    local confidence="$3"
    local reasoning="$4"
    local output="$5"
    local duration_ms="${6:-0}"

    if ! command -v jq >/dev/null; then
        echo "{\"model\":\"claude\",\"status\":\"$status\",\"decision\":\"$decision\"}"
        return
    fi

    jq -n \
        --arg model "claude" \
        --arg status "$status" \
        --arg decision "$decision" \
        --arg confidence "$confidence" \
        --arg reasoning "$reasoning" \
        --arg output "$output" \
        --arg trace_id "$TRACE_ID" \
        --argjson duration_ms "$duration_ms" \
        '{model: $model, status: $status, decision: $decision, confidence: ($confidence | tonumber), reasoning: $reasoning, output: $output, trace_id: $trace_id, duration_ms: $duration_ms}'
}

# --- Main Logic ---

PROMPT="${1:-}"
TIMEOUT="${DEFAULT_TIMEOUT}"

# Parse args (simplified for brevity, assume PROMPT is last)
while [[ $# -gt 0 ]]; do
    case "$1" in
        --timeout) TIMEOUT="$2"; shift 2 ;;
        -*) shift ;;
        *) PROMPT="$1"; shift ;;
    esac
done

if [[ -z "$PROMPT" ]]; then
    # Check stdin
    if [[ ! -t 0 ]]; then
        PROMPT=$(cat)
    fi
fi

if [[ -z "$PROMPT" ]]; then
    json_output "error" "ABSTAIN" "0.0" "No prompt provided" "" 0
    exit 1
fi

# 2. Execution
START_MS=$(date +%s%3N 2>/dev/null || echo $(($(date +%s) * 1000)))

# Use circuit_breaker_call if available, otherwise fallback to direct call
OUTPUT_TMP=$(mktemp)
if declare -f circuit_breaker_call >/dev/null; then
    circuit_breaker_call "claude" timeout "$TIMEOUT" "$CLAUDE_CMD" -p "$PROMPT" > "$OUTPUT_TMP" 2>&1
    EXIT_CODE=$?
else
    timeout "$TIMEOUT" "$CLAUDE_CMD" -p "$PROMPT" > "$OUTPUT_TMP" 2>&1
    EXIT_CODE=$?
fi
OUTPUT=$(cat "$OUTPUT_TMP")
rm -f "$OUTPUT_TMP"

END_MS=$(date +%s%3N 2>/dev/null || echo $(($(date +%s) * 1000)))
DURATION_MS=$((END_MS - START_MS))

# 3. Result Handling
if [[ $EXIT_CODE -eq 126 ]]; then
    # Breaker open
    json_output "error" "ABSTAIN" "0.0" "Circuit breaker OPEN" "" 0
    exit 1
elif [[ $EXIT_CODE -eq 0 ]]; then
    # Success (record_success handled by wrapper)
    
    # Simple heuristic parsing
    DECISION="ABSTAIN"
    if echo "$OUTPUT" | grep -qiE "APPROVE|YES|AGREE"; then DECISION="APPROVE"; fi
    if echo "$OUTPUT" | grep -qiE "REJECT|NO|DISAGREE"; then DECISION="REJECT"; fi
    
    json_output "success" "$DECISION" "0.9" "Executed successfully" "$OUTPUT" "$DURATION_MS"
    exit 0
else
    # Failure (record_failure handled by wrapper)
    
    json_output "error" "ABSTAIN" "0.0" "Execution failed (exit $EXIT_CODE)" "$OUTPUT" "$DURATION_MS"
    exit 1
fi
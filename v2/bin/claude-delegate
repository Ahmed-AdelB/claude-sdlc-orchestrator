#!/bin/bash
#===============================================================================
# claude-delegate - Wrapper for Claude CLI with JSON envelope output
#===============================================================================
# Wraps Claude CLI execution and outputs structured JSON response envelope.
# Features:
# - Circuit Breaker Integration
# - JSON Output
# - Cost Tracking
#===============================================================================

# Source common utilities
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/../lib"

if [[ -f "${LIB_DIR}/common.sh" ]]; then
    source "${LIB_DIR}/common.sh"
else
    echo '{"model":"claude","status":"error","decision":"ABSTAIN","confidence":0.0,"reasoning":"common.sh not found","output":"","trace_id":"unknown","duration_ms":0}'
    exit 1
fi

# Source Circuit Breaker
if [[ -f "${LIB_DIR}/circuit-breaker.sh" ]]; then
    source "${LIB_DIR}/circuit-breaker.sh"
    if declare -f load_breaker_config >/dev/null 2>&1; then
        load_breaker_config 2>/dev/null || true
    fi
    CB_FAILURE_THRESHOLD="${CB_FAILURE_THRESHOLD:-3}"
fi

COMPONENT="CLAUDE"
export COMPONENT
TRACE_ID="${TRACE_ID:-claude-$(date +%Y%m%d%H%M%S)-$$}"
export TRACE_ID

# Config
DEFAULT_TIMEOUT=300
CLAUDE_CMD="${CLAUDE_CMD:-claude}"

# JSON Output Helper
json_output() {
    local status="$1"
    local decision="$2"
    local confidence="$3"
    local reasoning="$4"
    local output="$5"
    local duration_ms="${6:-0}"

    if ! command -v jq >/dev/null; then
        echo "{\"model\":\"claude\",\"status\":\"$status\",\"decision\":\"$decision\"}"
        return
    fi

    jq -n \
        --arg model "claude" \
        --arg status "$status" \
        --arg decision "$decision" \
        --arg confidence "$confidence" \
        --arg reasoning "$reasoning" \
        --arg output "$output" \
        --arg trace_id "$TRACE_ID" \
        --argjson duration_ms "$duration_ms" \
        '{model: $model, status: $status, decision: $decision, confidence: ($confidence | tonumber), reasoning: $reasoning, output: $output, trace_id: $trace_id, duration_ms: $duration_ms}'
}

# Fallback helpers
FALLBACK_OUTPUT=""
FALLBACK_EXIT=0
FALLBACK_STDIN=""

_fallback_delegate_path() {
    local model="$1"
    echo "${SCRIPT_DIR}/${model}-delegate"
}

attempt_fallback() {
    local failed_model="$1"
    local reason="$2"

    if [[ "${TRI_FALLBACK_DISABLED:-false}" == "true" ]]; then
        return 1
    fi
    if [[ "${TRI_FALLBACK_IN_PROGRESS:-0}" == "1" ]]; then
        return 1
    fi

    local next_model=""
    if declare -f fallback_to_next_model >/dev/null 2>&1; then
        next_model=$(fallback_to_next_model "$failed_model") || return 1
    else
        case "$failed_model" in
            "claude") next_model="codex" ;;
            "codex") next_model="gemini" ;;
            *) return 1 ;;
        esac
    fi

    local delegate_path
    delegate_path=$(_fallback_delegate_path "$next_model")
    if [[ ! -x "$delegate_path" ]]; then
        log_warn "[${TRACE_ID:-unknown}] Fallback delegate not found for ${next_model}: ${delegate_path}"
        return 1
    fi

    if declare -F log_claude >/dev/null 2>&1; then
        log_claude "WARN" "FALLBACK" "Fallback from ${failed_model} to ${next_model}" \
            "{\"trace_id\":\"${TRACE_ID}\",\"reason\":\"${reason}\"}"
    else
        log_warn "[${TRACE_ID:-unknown}] Fallback from ${failed_model} to ${next_model} (reason: ${reason})"
    fi

    local output=""
    local exit_code=0
    if [[ -n "$FALLBACK_STDIN" ]]; then
        output=$(printf '%s' "$FALLBACK_STDIN" | TRI_FALLBACK_IN_PROGRESS=1 "$delegate_path" --timeout "$TIMEOUT" "$PROMPT") || exit_code=$?
    else
        output=$(TRI_FALLBACK_IN_PROGRESS=1 "$delegate_path" --timeout "$TIMEOUT" "$PROMPT") || exit_code=$?
    fi

    FALLBACK_OUTPUT="$output"
    FALLBACK_EXIT="$exit_code"
    return 0
}

# --- Main Logic ---

PROMPT="${1:-}"
TIMEOUT="${DEFAULT_TIMEOUT}"

# Parse args (simplified for brevity, assume PROMPT is last)
while [[ $# -gt 0 ]]; do
    case "$1" in
        --timeout) TIMEOUT="$2"; shift 2 ;;
        -*) shift ;;
        *) PROMPT="$1"; shift ;;
    esac
done

if [[ -z "$PROMPT" ]]; then
    # Check stdin
    if [[ ! -t 0 ]]; then
        PROMPT=$(cat)
    fi
fi

if [[ -z "$PROMPT" ]]; then
    json_output "error" "ABSTAIN" "0.0" "No prompt provided" "" 0
    exit 1
fi

# 2. Execution
START_MS=$(date +%s%3N 2>/dev/null || echo $(($(date +%s) * 1000)))

# Use circuit_breaker_call if available, otherwise fallback to direct call
OUTPUT_TMP=$(secure_mktemp "claude-delegate.${TRACE_ID}.stderr") || { json_output "error" "ABSTAIN" "0.0" "Failed to create temp file" "" 0; exit 1; }
if declare -f circuit_breaker_call >/dev/null; then
    circuit_breaker_call "claude" timeout "$TIMEOUT" "$CLAUDE_CMD" -p "$PROMPT" > "$OUTPUT_TMP" 2>&1
    EXIT_CODE=$?
else
    timeout "$TIMEOUT" "$CLAUDE_CMD" -p "$PROMPT" > "$OUTPUT_TMP" 2>&1
    EXIT_CODE=$?
fi
OUTPUT=$(cat "$OUTPUT_TMP")
rm -f "$OUTPUT_TMP"

END_MS=$(date +%s%3N 2>/dev/null || echo $(($(date +%s) * 1000)))
DURATION_MS=$((END_MS - START_MS))

# 3. Result Handling
if [[ $EXIT_CODE -ne 0 ]]; then
    failure_reason="Execution failed (exit $EXIT_CODE)"
    if [[ $EXIT_CODE -eq 126 ]]; then
        failure_reason="Circuit breaker OPEN"
    fi
    if attempt_fallback "claude" "$failure_reason"; then
        printf '%s\n' "$FALLBACK_OUTPUT"
        exit "$FALLBACK_EXIT"
    fi
fi

if [[ $EXIT_CODE -eq 126 ]]; then
    # Breaker open
    json_output "error" "ABSTAIN" "0.0" "Circuit breaker OPEN" "" 0
    exit 1
elif [[ $EXIT_CODE -eq 0 ]]; then
    # Success (record_success handled by wrapper)
    
    # Simple heuristic parsing
    DECISION="ABSTAIN"
    if echo "$OUTPUT" | grep -qiE "APPROVE|YES|AGREE"; then DECISION="APPROVE"; fi
    if echo "$OUTPUT" | grep -qiE "REJECT|NO|DISAGREE"; then DECISION="REJECT"; fi
    
    json_output "success" "$DECISION" "0.9" "Executed successfully" "$OUTPUT" "$DURATION_MS"
    exit 0
else
    # Failure (record_failure handled by wrapper)
    
    json_output "error" "ABSTAIN" "0.0" "Execution failed (exit $EXIT_CODE)" "$OUTPUT" "$DURATION_MS"
    exit 1
fi

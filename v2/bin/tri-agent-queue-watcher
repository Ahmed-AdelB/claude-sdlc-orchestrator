#!/bin/bash
#===============================================================================
# tri-agent-queue-watcher - Queue-to-SQLite Bridge Daemon (M1-002 v2.1)
#===============================================================================
# Features:
# - Monitors file-based task queue (tasks/queue/)
# - Bridges tasks into SQLite automatically
# - inotifywait support with polling fallback
# - Priority extraction from filename, frontmatter, or directory
# - Idempotent task creation (no duplicates)
# - Bidirectional sync verification
# - Graceful shutdown with signal handling
# - Comprehensive error handling and logging
#===============================================================================

set -euo pipefail
IFS=$'\n\t'

# =============================================================================
# Path Resolution
# =============================================================================
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
AUTONOMOUS_ROOT="${AUTONOMOUS_ROOT:-$(cd "${SCRIPT_DIR}/.." && pwd)}"

# =============================================================================
# Source Common Utilities
# =============================================================================
if [[ -f "${AUTONOMOUS_ROOT}/lib/common.sh" ]]; then
    # shellcheck source=/dev/null
    source "${AUTONOMOUS_ROOT}/lib/common.sh"
else
    echo "ERROR: lib/common.sh not found at ${AUTONOMOUS_ROOT}/lib/common.sh" >&2
    exit 1
fi

# =============================================================================
# Source SQLite State Library
# =============================================================================
if [[ -f "${AUTONOMOUS_ROOT}/lib/sqlite-state.sh" ]]; then
    # shellcheck source=/dev/null
    source "${AUTONOMOUS_ROOT}/lib/sqlite-state.sh"
else
    log_error "lib/sqlite-state.sh not found - required for queue bridging"
    exit 1
fi

# =============================================================================
# Configuration
# =============================================================================
QUEUE_ROOT="${QUEUE_ROOT:-${AUTONOMOUS_ROOT}/tasks/queue}"
RUNNING_DIR="${RUNNING_DIR:-${AUTONOMOUS_ROOT}/tasks/running}"
COMPLETED_DIR="${COMPLETED_DIR:-${AUTONOMOUS_ROOT}/tasks/completed}"
FAILED_DIR="${FAILED_DIR:-${AUTONOMOUS_ROOT}/tasks/failed}"
STATE_DIR="${STATE_DIR:-${AUTONOMOUS_ROOT}/state}"
STATE_DB="${STATE_DB:-${STATE_DIR}/tri-agent.db}"
PID_FILE="${PID_FILE:-${STATE_DIR}/queue-watcher.pid}"
LOG_FILE="${LOG_FILE:-${AUTONOMOUS_ROOT}/logs/queue-watcher.log}"

# Timing configuration
POLL_INTERVAL="${POLL_INTERVAL:-5}"
INOTIFY_TIMEOUT="${INOTIFY_TIMEOUT:-30}"
SYNC_CHECK_INTERVAL="${SYNC_CHECK_INTERVAL:-60}"

# Use inotifywait if available (more efficient)
USE_INOTIFY="${USE_INOTIFY:-auto}"

# Running state
RUNNING=true
SCAN_COUNT=0
BRIDGE_COUNT=0
LAST_SYNC_CHECK=0

# =============================================================================
# Signal Handlers
# =============================================================================
handle_shutdown() {
    log_info "Received shutdown signal, cleaning up..."
    RUNNING=false

    # Remove PID file
    if [[ -f "$PID_FILE" ]]; then
        rm -f "$PID_FILE" 2>/dev/null || true
    fi

    log_info "Queue watcher stopped (bridged $BRIDGE_COUNT tasks in $SCAN_COUNT scans)"
    exit 0
}

handle_reload() {
    log_info "Received reload signal, re-reading configuration..."
    # Could reload config from file here
    log_info "Configuration reloaded"
}

# Set up signal handlers
trap handle_shutdown SIGTERM SIGINT SIGHUP
trap handle_reload SIGUSR1

# =============================================================================
# Logging Helpers
# =============================================================================
_log_to_file() {
    local level="$1"
    local message="$2"
    local timestamp
    timestamp=$(date -Iseconds)

    # Ensure log directory exists
    mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null || true

    echo "[$timestamp] [${TRACE_ID:-watcher}] [$level] $message" >> "$LOG_FILE" 2>/dev/null || true
}

watcher_log_info() {
    log_info "$*"
    _log_to_file "INFO" "$*"
}

watcher_log_warn() {
    log_warn "$*"
    _log_to_file "WARN" "$*"
}

watcher_log_error() {
    log_error "$*"
    _log_to_file "ERROR" "$*"
}

watcher_log_debug() {
    if [[ "${DEBUG:-0}" == "1" ]]; then
        log_debug "$*"
        _log_to_file "DEBUG" "$*"
    fi
}

# =============================================================================
# Priority Parsing
# =============================================================================

# Extract priority from various sources
# Order: filename prefix > YAML frontmatter > parent directory > default
parse_priority() {
    local path="$1"
    local filename
    filename=$(basename "$path")
    local priority=""

    # 1. Check filename prefix (e.g., CRITICAL_M1-001_task.md)
    priority=$(echo "$filename" | grep -oE '^(CRITICAL|HIGH|MEDIUM|LOW)[_-]' | tr -d '_-' || true)
    if [[ -n "$priority" ]]; then
        echo "$priority"
        return 0
    fi

    # 2. Check YAML frontmatter in file
    if [[ -f "$path" ]]; then
        # Look for priority: in YAML frontmatter (between --- markers)
        local frontmatter_priority
        frontmatter_priority=$(awk '
            /^---$/ { in_frontmatter = !in_frontmatter; next }
            in_frontmatter && /^priority:/ {
                gsub(/priority:[[:space:]]*/, "");
                gsub(/[[:space:]]*$/, "");
                print toupper($0);
                exit
            }
        ' "$path" 2>/dev/null || true)

        if [[ "$frontmatter_priority" =~ ^(CRITICAL|HIGH|MEDIUM|LOW)$ ]]; then
            echo "$frontmatter_priority"
            return 0
        fi
    fi

    # 3. Check parent directory name
    local parent
    parent=$(basename "$(dirname "$path")")
    case "${parent^^}" in
        CRITICAL|HIGH|MEDIUM|LOW)
            echo "${parent^^}"
            return 0
            ;;
    esac

    # 4. Default to MEDIUM
    echo "MEDIUM"
}

# Extract task type from filename or content
parse_task_type() {
    local path="$1"
    local filename
    filename=$(basename "$path")

    # Check for type prefix after priority (e.g., CRITICAL_feature_M1-001.md)
    local type_match
    type_match=$(echo "$filename" | grep -oE '(feature|bugfix|refactor|test|docs|chore|security)' | head -1 || true)
    if [[ -n "$type_match" ]]; then
        echo "$type_match"
        return 0
    fi

    # Check YAML frontmatter
    if [[ -f "$path" ]]; then
        local frontmatter_type
        frontmatter_type=$(awk '
            /^---$/ { in_frontmatter = !in_frontmatter; next }
            in_frontmatter && /^type:/ {
                gsub(/type:[[:space:]]*/, "");
                gsub(/[[:space:]]*$/, "");
                print $0;
                exit
            }
        ' "$path" 2>/dev/null || true)

        if [[ -n "$frontmatter_type" ]]; then
            echo "$frontmatter_type"
            return 0
        fi
    fi

    # Default to general
    echo "general"
}

# Extract description from task file
parse_description() {
    local path="$1"
    local description=""

    if [[ -f "$path" ]]; then
        # Try to find first markdown heading
        description=$(head -20 "$path" 2>/dev/null | grep -E '^#+ ' | head -1 | sed 's/^#* *//' | sed 's/\[.*\] *//' || true)

        # If no heading, use first non-empty, non-frontmatter line
        if [[ -z "$description" ]]; then
            description=$(awk '
                /^---$/ { in_frontmatter = !in_frontmatter; next }
                !in_frontmatter && /^[^#]/ && NF { print; exit }
            ' "$path" 2>/dev/null | head -c 200 || true)
        fi
    fi

    # Fallback to task ID
    if [[ -z "$description" ]]; then
        description=$(basename "$path" | sed 's/\.md$//')
    fi

    # Limit length and remove problematic characters
    description="${description:0:200}"
    # Remove null bytes and control characters
    description=$(printf '%s' "$description" | tr -d '\0' | tr -d '\001-\037')

    echo "$description"
}

# =============================================================================
# SQLite Operations (with error handling)
# =============================================================================

# Check if task exists in SQLite
task_exists_in_sqlite() {
    local task_id="$1"
    local escaped_id
    escaped_id=$(_sql_escape "$task_id")

    local result
    result=$(_sqlite_exec "$STATE_DB" "SELECT COUNT(*) FROM tasks WHERE id='${escaped_id}';" 2>/dev/null || echo "0")

    [[ "${result:-0}" -gt 0 ]]
}

# Escape string for safe SQLite insertion (comprehensive)
# Handles single quotes, null bytes, and other special characters
safe_sql_escape() {
    local value="${1:-}"
    # Remove null bytes first (SQLite cannot store them)
    value=$(printf '%s' "$value" | tr -d '\0')
    # Escape single quotes by doubling them (SQL standard)
    value="${value//\'/\'\'}"
    printf '%s' "$value"
}

# Create task in SQLite with comprehensive metadata
create_task_from_file() {
    local file="$1"
    local task_id
    task_id=$(basename "$file" | sed 's/\.md$//')

    # Skip if already exists
    if task_exists_in_sqlite "$task_id"; then
        watcher_log_debug "Task already exists in SQLite: $task_id"
        return 1
    fi

    # Parse task metadata
    local priority type description
    priority=$(parse_priority "$file")
    type=$(parse_task_type "$file")
    description=$(parse_description "$file")

    # Generate checksum for change detection
    local checksum=""
    if command -v md5sum >/dev/null 2>&1; then
        checksum=$(md5sum "$file" 2>/dev/null | cut -d' ' -f1 || true)
    elif command -v md5 >/dev/null 2>&1; then
        checksum=$(md5 -q "$file" 2>/dev/null || true)
    fi

    # Escape all values for SQL
    local esc_id esc_name esc_type esc_desc esc_checksum
    esc_id=$(safe_sql_escape "$task_id")
    esc_name=$(safe_sql_escape "$description")
    esc_type=$(safe_sql_escape "$type")
    esc_desc=$(safe_sql_escape "$description")
    esc_checksum=$(safe_sql_escape "$checksum")

    # Get priority integer
    local p_int
    p_int=$(priority_to_int "$priority")

    # Store file path reference instead of full content (avoids escaping issues)
    # The payload stores a reference that can be used to read the original file
    local esc_payload
    esc_payload=$(safe_sql_escape "file://${file}")

    # Create task in SQLite using direct SQL (bypass create_task for full control)
    local trace_id="${TRACE_ID:-watcher-$$}"
    local esc_trace
    esc_trace=$(safe_sql_escape "$trace_id")

    if _sqlite_exec "$STATE_DB" "INSERT OR IGNORE INTO tasks (id, name, type, priority, state, payload, trace_id, checksum, created_at, updated_at) VALUES ('${esc_id}','${esc_name}','${esc_type}',${p_int},'QUEUED','${esc_payload}','${esc_trace}','${esc_checksum}',datetime('now'),datetime('now'));" 2>/dev/null; then
        watcher_log_info "Bridged task: $task_id (priority: $priority, type: $type)"
        return 0
    else
        watcher_log_error "Failed to create task in SQLite: $task_id"
        return 1
    fi
}

# =============================================================================
# Synchronization Functions
# =============================================================================

# Scan queue directory and bridge all tasks
scan_queue_directory() {
    local bridged_this_scan=0

    if [[ ! -d "$QUEUE_ROOT" ]]; then
        watcher_log_warn "Queue directory does not exist: $QUEUE_ROOT"
        mkdir -p "$QUEUE_ROOT" 2>/dev/null || true
        return 0
    fi

    # Find all .md files in queue (including priority subdirectories)
    while IFS= read -r -d '' file; do
        if [[ -f "$file" && -r "$file" ]]; then
            if create_task_from_file "$file"; then
                bridged_this_scan=$((bridged_this_scan + 1))
                BRIDGE_COUNT=$((BRIDGE_COUNT + 1))
            fi
        fi
    done < <(find "$QUEUE_ROOT" -type f -name "*.md" -print0 2>/dev/null)

    SCAN_COUNT=$((SCAN_COUNT + 1))

    if [[ $bridged_this_scan -gt 0 ]]; then
        watcher_log_info "Scan #$SCAN_COUNT: Bridged $bridged_this_scan new tasks (total: $BRIDGE_COUNT)"
    else
        watcher_log_debug "Scan #$SCAN_COUNT: No new tasks to bridge"
    fi

    return $bridged_this_scan
}

# Verify SQLite-to-file synchronization (find orphaned SQLite entries)
verify_sync() {
    watcher_log_debug "Running synchronization verification..."

    local orphaned_count=0
    local file_missing_count=0

    # Get all QUEUED tasks from SQLite
    local queued_tasks
    queued_tasks=$(_sqlite_exec "$STATE_DB" "SELECT id FROM tasks WHERE state='QUEUED';" 2>/dev/null || true)

    if [[ -n "$queued_tasks" ]]; then
        while IFS= read -r task_id; do
            [[ -z "$task_id" ]] && continue

            # Check if corresponding file exists
            local found=false

            # Check in queue root
            if [[ -f "$QUEUE_ROOT/${task_id}.md" ]]; then
                found=true
            else
                # Check in priority subdirectories
                for priority_dir in "$QUEUE_ROOT"/{CRITICAL,HIGH,MEDIUM,LOW}; do
                    if [[ -f "$priority_dir/${task_id}.md" ]]; then
                        found=true
                        break
                    fi
                done
            fi

            if [[ "$found" == "false" ]]; then
                file_missing_count=$((file_missing_count + 1))
                watcher_log_warn "Task in SQLite but file missing: $task_id"

                # Optionally mark as orphaned or remove
                # For now, just log the discrepancy
            fi
        done <<< "$queued_tasks"
    fi

    if [[ $file_missing_count -gt 0 ]]; then
        watcher_log_warn "Sync check found $file_missing_count tasks with missing files"
    else
        watcher_log_debug "Sync check complete: all SQLite tasks have corresponding files"
    fi

    LAST_SYNC_CHECK=$(date +%s)
}

# =============================================================================
# Watch Modes
# =============================================================================

# Poll-based watching (fallback)
watch_with_polling() {
    watcher_log_info "Starting poll-based watching (interval: ${POLL_INTERVAL}s)"

    while $RUNNING; do
        scan_queue_directory

        # Periodic sync verification
        local now
        now=$(date +%s)
        if [[ $((now - LAST_SYNC_CHECK)) -ge $SYNC_CHECK_INTERVAL ]]; then
            verify_sync
        fi

        # Sleep in small increments for responsive shutdown
        local sleep_remaining=$POLL_INTERVAL
        while [[ $sleep_remaining -gt 0 ]] && $RUNNING; do
            sleep 1
            sleep_remaining=$((sleep_remaining - 1))
        done
    done
}

# inotifywait-based watching (more efficient)
watch_with_inotify() {
    watcher_log_info "Starting inotifywait-based watching"

    # Initial scan
    scan_queue_directory

    # Watch for file system events
    while $RUNNING; do
        # Use timeout to allow periodic sync checks
        if inotifywait -q -t "$INOTIFY_TIMEOUT" -e create -e moved_to -e modify \
            --format '%w%f' -r "$QUEUE_ROOT" 2>/dev/null | while read -r file; do

            if [[ "$file" == *.md && -f "$file" ]]; then
                watcher_log_debug "inotify event on: $file"
                create_task_from_file "$file" || true
            fi
        done; then
            # File event received - continue
            :
        else
            # Timeout or error - do periodic scan
            scan_queue_directory
        fi

        # Periodic sync verification
        local now
        now=$(date +%s)
        if [[ $((now - LAST_SYNC_CHECK)) -ge $SYNC_CHECK_INTERVAL ]]; then
            verify_sync
        fi
    done
}

# =============================================================================
# Main Watch Loop
# =============================================================================

start_watching() {
    watcher_log_info "Queue watcher starting (PID $$)"
    watcher_log_info "  AUTONOMOUS_ROOT: $AUTONOMOUS_ROOT"
    watcher_log_info "  Queue directory: $QUEUE_ROOT"
    watcher_log_info "  State database:  $STATE_DB"
    watcher_log_info "  Log file:        $LOG_FILE"

    # Ensure directories exist
    mkdir -p "$QUEUE_ROOT" "$STATE_DIR" "$(dirname "$LOG_FILE")" 2>/dev/null || true

    # Initialize database
    if ! sqlite_state_init "$STATE_DB" >/dev/null 2>&1; then
        watcher_log_error "Failed to initialize SQLite database"
        exit 1
    fi

    # Write PID file
    echo $$ > "$PID_FILE"
    chmod 644 "$PID_FILE" 2>/dev/null || true

    # Determine watch mode
    local use_inotify=false

    if [[ "$USE_INOTIFY" == "true" ]] || [[ "$USE_INOTIFY" == "auto" ]]; then
        if command -v inotifywait >/dev/null 2>&1; then
            use_inotify=true
            watcher_log_info "Using inotifywait for file system monitoring"
        else
            watcher_log_info "inotifywait not available, falling back to polling"
        fi
    else
        watcher_log_info "inotifywait disabled, using polling"
    fi

    # Initial sync check
    LAST_SYNC_CHECK=$(date +%s)

    # Start appropriate watch mode
    if $use_inotify; then
        watch_with_inotify
    else
        watch_with_polling
    fi
}

# =============================================================================
# One-time Operations
# =============================================================================

# One-time scan and bridge
run_once() {
    watcher_log_info "Running one-time queue scan..."

    # Initialize database
    sqlite_state_init "$STATE_DB" >/dev/null 2>&1 || true

    # Scan and report
    local bridged=0

    if [[ -d "$QUEUE_ROOT" ]]; then
        while IFS= read -r -d '' file; do
            if [[ -f "$file" ]]; then
                local task_id
                task_id=$(basename "$file" | sed 's/\.md$//')

                if create_task_from_file "$file"; then
                    bridged=$((bridged + 1))
                    echo "BRIDGED: $task_id"
                else
                    echo "EXISTS:  $task_id"
                fi
            fi
        done < <(find "$QUEUE_ROOT" -type f -name "*.md" -print0 2>/dev/null)
    fi

    echo ""
    echo "Summary: Bridged $bridged new tasks"
}

# Show current status
show_status() {
    echo "=== Queue Watcher Status ==="
    echo ""

    # Check if daemon is running
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE" 2>/dev/null || echo "")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            echo "Daemon:     RUNNING (PID $pid)"
        else
            echo "Daemon:     STOPPED (stale PID file)"
        fi
    else
        echo "Daemon:     STOPPED"
    fi

    echo ""
    echo "Queue Directory: $QUEUE_ROOT"
    echo "State Database:  $STATE_DB"
    echo ""

    # Count files in queue
    local queue_files=0
    if [[ -d "$QUEUE_ROOT" ]]; then
        queue_files=$(find "$QUEUE_ROOT" -type f -name "*.md" 2>/dev/null | wc -l)
    fi
    echo "Files in queue:  $queue_files"

    # Count tasks in SQLite by state
    if [[ -f "$STATE_DB" ]]; then
        echo ""
        echo "SQLite Task States:"

        # Use Python for reliable output
        python3 -c "
import sqlite3
try:
    conn = sqlite3.connect('$STATE_DB')
    cur = conn.cursor()
    cur.execute('SELECT state, COUNT(*) FROM tasks GROUP BY state ORDER BY state')
    for row in cur.fetchall():
        print(f'  {row[0]:<12} {row[1]}')
    conn.close()
except Exception as e:
    print(f'  (error: {e})')
" 2>/dev/null || echo "  (unable to query database)"
    fi

    # Show priority distribution
    if [[ -f "$STATE_DB" ]]; then
        echo ""
        echo "Priority Distribution:"
        python3 -c "
import sqlite3
priorities = {0: 'CRITICAL', 1: 'HIGH', 2: 'MEDIUM', 3: 'LOW'}
try:
    conn = sqlite3.connect('$STATE_DB')
    cur = conn.cursor()
    cur.execute('SELECT priority, COUNT(*) FROM tasks WHERE state=\"QUEUED\" GROUP BY priority ORDER BY priority')
    for row in cur.fetchall():
        pname = priorities.get(row[0], 'UNKNOWN')
        print(f'  {pname:<12} {row[1]}')
    conn.close()
except:
    pass
" 2>/dev/null
    fi

    echo ""
}

# Stop running daemon
stop_daemon() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE" 2>/dev/null || echo "")
        if [[ -n "$pid" ]]; then
            if kill -0 "$pid" 2>/dev/null; then
                echo "Stopping queue watcher (PID $pid)..."
                kill -TERM "$pid" 2>/dev/null || true

                # Wait for graceful shutdown
                local wait_count=0
                while kill -0 "$pid" 2>/dev/null && [[ $wait_count -lt 10 ]]; do
                    sleep 1
                    wait_count=$((wait_count + 1))
                done

                if kill -0 "$pid" 2>/dev/null; then
                    echo "Force killing..."
                    kill -9 "$pid" 2>/dev/null || true
                fi

                rm -f "$PID_FILE" 2>/dev/null || true
                echo "Stopped"
            else
                echo "Daemon not running (stale PID file removed)"
                rm -f "$PID_FILE" 2>/dev/null || true
            fi
        fi
    else
        echo "No PID file found - daemon may not be running"
    fi
}

# =============================================================================
# Help / Usage
# =============================================================================

show_help() {
    cat <<EOF
tri-agent-queue-watcher - Queue-to-SQLite Bridge Daemon (M1-002)

USAGE:
    tri-agent-queue-watcher [OPTIONS]

OPTIONS:
    (none)          Start watching daemon (foreground)
    --once          Scan queue once, bridge tasks, then exit
    --status        Show current daemon and queue status
    --stop          Stop running daemon
    --help, -h      Show this help message

DESCRIPTION:
    Monitors the file-based task queue (tasks/queue/) and automatically
    creates corresponding entries in SQLite. This makes SQLite the canonical
    task store while maintaining file queue compatibility.

    The watcher uses inotifywait for efficient file system monitoring when
    available, falling back to polling otherwise.

PRIORITY DETECTION:
    Priority is extracted from (in order):
    1. Filename prefix (e.g., CRITICAL_M1-001_task.md)
    2. YAML frontmatter (priority: HIGH)
    3. Parent directory (e.g., tasks/queue/HIGH/task.md)
    4. Default: MEDIUM

TASK TYPE DETECTION:
    Type is extracted from:
    1. Filename pattern (feature, bugfix, refactor, test, docs, chore, security)
    2. YAML frontmatter (type: feature)
    3. Default: general

ENVIRONMENT VARIABLES:
    POLL_INTERVAL         Polling interval in seconds (default: 5)
    INOTIFY_TIMEOUT       inotifywait timeout in seconds (default: 30)
    SYNC_CHECK_INTERVAL   Sync verification interval in seconds (default: 60)
    USE_INOTIFY           Use inotifywait: auto|true|false (default: auto)
    TRACE_ID              Trace ID for bridged tasks (default: watcher-PID)
    DEBUG                 Enable debug logging: 0|1 (default: 0)

FILES:
    $QUEUE_ROOT/
        Task files to watch (.md files)

    $STATE_DB
        SQLite database for task state

    $PID_FILE
        Daemon PID file

    $LOG_FILE
        Watcher log file

EXAMPLES:
    # Run as foreground daemon
    ./bin/tri-agent-queue-watcher

    # Run in background
    ./bin/tri-agent-queue-watcher &

    # Run with debug logging
    DEBUG=1 ./bin/tri-agent-queue-watcher

    # One-time scan and bridge
    ./bin/tri-agent-queue-watcher --once

    # Check status
    ./bin/tri-agent-queue-watcher --status

    # Stop daemon
    ./bin/tri-agent-queue-watcher --stop

SEE ALSO:
    tri-agent-worker(1), sqlite-state.sh(3)

EOF
}

# =============================================================================
# Main Entry Point
# =============================================================================

main() {
    case "${1:-}" in
        --once|-1)
            run_once
            ;;
        --status|-s)
            show_status
            ;;
        --stop)
            stop_daemon
            ;;
        --help|-h)
            show_help
            ;;
        "")
            start_watching
            ;;
        *)
            echo "Unknown option: $1" >&2
            echo "Use --help for usage information" >&2
            exit 1
            ;;
    esac
}

# Run main
main "$@"

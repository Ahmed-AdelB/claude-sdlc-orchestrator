#!/bin/bash
#===============================================================================
# tri-agent-queue-watcher - Queue-to-SQLite Bridge Daemon (M1-002)
#===============================================================================
# Features:
# - M1-002: Watches filesystem queue and syncs to SQLite
# - Inotify-based monitoring (with polling fallback)
# - Priority detection from filename and directory
# - Task metadata extraction from file content
# - Atomic registration via sqlite_state_init
# - Daemon mode with PID management
# - SIGTERM graceful shutdown
#
# Purpose:
# This daemon bridges the gap between filesystem-based task creation
# (e.g., dropping .md files into tasks/queue/) and SQLite-based task
# management. It ensures all tasks are registered in SQLite for proper
# claiming by workers.
#
# Supported Patterns:
# - tasks/queue/*.md           -> MEDIUM priority
# - tasks/queue/CRITICAL/*.md  -> CRITICAL priority
# - tasks/queue/HIGH/*.md      -> HIGH priority
# - tasks/queue/MEDIUM/*.md    -> MEDIUM priority
# - tasks/queue/LOW/*.md       -> LOW priority
# - CRITICAL_*.md prefix       -> CRITICAL priority (overrides dir)
# - HIGH_*.md prefix           -> HIGH priority
#
# Usage:
#   tri-agent-queue-watcher           # Start daemon
#   tri-agent-queue-watcher --once    # Single sync and exit
#   tri-agent-queue-watcher --status  # Show sync status
#===============================================================================

set -euo pipefail

# Resolve paths
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
AUTONOMOUS_ROOT="${AUTONOMOUS_ROOT:-$(cd "${SCRIPT_DIR}/.." && pwd)}"

# Source common utilities
source "${AUTONOMOUS_ROOT}/lib/common.sh"

# Source SQLite State
if [[ -f "${AUTONOMOUS_ROOT}/lib/sqlite-state.sh" ]]; then
    source "${AUTONOMOUS_ROOT}/lib/sqlite-state.sh"
else
    echo "ERROR: lib/sqlite-state.sh not found" >&2
    exit 1
fi

# Config
VERSION="1.0.0"
QUEUE_DIR="${AUTONOMOUS_ROOT}/tasks/queue"
STATE_DIR="${AUTONOMOUS_ROOT}/state"
PID_FILE="${STATE_DIR}/queue-watcher.pid"
SYNC_INTERVAL="${SYNC_INTERVAL:-10}"  # Polling interval in seconds
USE_INOTIFY="${USE_INOTIFY:-auto}"    # auto, yes, no

# Track sync statistics
SYNC_COUNT=0
TASKS_REGISTERED=0
LAST_SYNC_TIME=""
RUNNING=true

#===============================================================================
# Signal Handling
#===============================================================================

handle_shutdown() {
    log_info "Queue watcher received shutdown signal"
    RUNNING=false
}

handle_reload() {
    log_info "Queue watcher: Reloading configuration"
    # Re-source config if needed
}

trap handle_shutdown SIGTERM SIGINT
trap handle_reload SIGHUP

#===============================================================================
# Priority Detection
#===============================================================================

# Detect priority from filename and directory path
detect_priority() {
    local filepath="$1"
    local filename
    filename=$(basename "$filepath")
    local dirpath
    dirpath=$(dirname "$filepath")
    local dirname
    dirname=$(basename "$dirpath")

    # Check filename prefix first (highest precedence)
    if [[ "$filename" =~ ^CRITICAL[_-] ]]; then
        echo "CRITICAL"
        return
    elif [[ "$filename" =~ ^HIGH[_-] ]]; then
        echo "HIGH"
        return
    elif [[ "$filename" =~ ^MEDIUM[_-] ]]; then
        echo "MEDIUM"
        return
    elif [[ "$filename" =~ ^LOW[_-] ]]; then
        echo "LOW"
        return
    fi

    # Check parent directory name
    case "$dirname" in
        CRITICAL|critical)
            echo "CRITICAL"
            ;;
        HIGH|high)
            echo "HIGH"
            ;;
        MEDIUM|medium)
            echo "MEDIUM"
            ;;
        LOW|low)
            echo "LOW"
            ;;
        *)
            echo "MEDIUM"  # Default
            ;;
    esac
}

#===============================================================================
# Task Metadata Extraction
#===============================================================================

# Extract task type from file content
extract_task_type() {
    local filepath="$1"
    local type="general"

    if [[ -f "$filepath" ]]; then
        # Look for type: field in YAML frontmatter or markdown
        local extracted
        extracted=$(grep -m1 -E "^type:\s*|^## Type:\s*" "$filepath" 2>/dev/null | sed 's/.*:\s*//' | tr -d '[:space:]' || echo "")
        if [[ -n "$extracted" ]]; then
            type="$extracted"
        fi
    fi

    echo "$type"
}

# Extract task name from file content or filename
extract_task_name() {
    local filepath="$1"
    local filename
    filename=$(basename "$filepath" .md)
    local name="$filename"

    if [[ -f "$filepath" ]]; then
        # Look for title in first H1 heading
        local extracted
        extracted=$(grep -m1 "^# " "$filepath" 2>/dev/null | sed 's/^# //' || echo "")
        if [[ -n "$extracted" ]]; then
            name="$extracted"
        fi
    fi

    echo "$name"
}

# Extract shard/lane from file content
extract_shard() {
    local filepath="$1"
    local shard=""

    if [[ -f "$filepath" ]]; then
        # Look for shard: or lane: field
        local extracted
        extracted=$(grep -m1 -E "^(shard|lane):\s*" "$filepath" 2>/dev/null | sed 's/.*:\s*//' | tr -d '[:space:]' || echo "")
        if [[ -n "$extracted" ]]; then
            shard="$extracted"
        fi
    fi

    echo "$shard"
}

# Extract assigned model from file content
extract_model() {
    local filepath="$1"
    local model=""

    if [[ -f "$filepath" ]]; then
        # Look for model: or assigned_model: field
        local extracted
        extracted=$(grep -m1 -E "^(model|assigned_model):\s*" "$filepath" 2>/dev/null | sed 's/.*:\s*//' | tr -d '[:space:]' || echo "")
        if [[ -n "$extracted" ]]; then
            model="$extracted"
        fi
    fi

    echo "$model"
}

#===============================================================================
# Task Registration
#===============================================================================

# Register a single task file to SQLite
register_task() {
    local filepath="$1"

    if [[ ! -f "$filepath" ]]; then
        log_debug "File no longer exists: $filepath"
        return 1
    fi

    local filename
    filename=$(basename "$filepath")
    local task_id="${filename%.md}"

    # Check if task already exists in SQLite
    local existing
    existing=$(_sqlite_exec "$STATE_DB" "SELECT id FROM tasks WHERE id='${task_id//\'/\'\'}' LIMIT 1;" 2>/dev/null || echo "")

    if [[ -n "$existing" ]]; then
        log_debug "Task already registered: $task_id"
        return 0
    fi

    # Extract metadata
    local priority
    priority=$(detect_priority "$filepath")
    local priority_int
    priority_int=$(priority_to_int "$priority")
    local task_type
    task_type=$(extract_task_type "$filepath")
    local task_name
    task_name=$(extract_task_name "$filepath")
    local shard
    shard=$(extract_shard "$filepath")
    local model
    model=$(extract_model "$filepath")

    # Escape for SQL
    local esc_id="${task_id//\'/\'\'}"
    local esc_name="${task_name//\'/\'\'}"
    local esc_type="${task_type//\'/\'\'}"
    local esc_shard="${shard//\'/\'\'}"
    local esc_model="${model//\'/\'\'}"

    # Register in SQLite
    _sqlite_exec "$STATE_DB" <<SQL
INSERT OR IGNORE INTO tasks (
    id, name, type, priority, state, shard, assigned_model,
    created_at, updated_at, trace_id
) VALUES (
    '${esc_id}',
    '${esc_name}',
    '${esc_type}',
    ${priority_int},
    'QUEUED',
    NULLIF('${esc_shard}', ''),
    NULLIF('${esc_model}', ''),
    datetime('now'),
    datetime('now'),
    '${TRACE_ID}'
);

-- Log registration event
INSERT INTO events (task_id, event_type, actor, payload, trace_id)
SELECT '${esc_id}', 'TASK_REGISTERED', 'queue-watcher',
    json_object('priority', '${priority}', 'type', '${esc_type}', 'shard', '${esc_shard}', 'model', '${esc_model}'),
    '${TRACE_ID}'
WHERE changes() > 0;
SQL

    if [[ $? -eq 0 ]]; then
        log_info "M1-002: Registered task $task_id (priority: $priority, type: $task_type)"
        ((TASKS_REGISTERED++)) || true
        return 0
    else
        log_error "Failed to register task: $task_id"
        return 1
    fi
}

#===============================================================================
# Queue Scanning
#===============================================================================

# Scan all queue directories and register tasks
scan_queue() {
    local registered=0
    local scanned=0

    # Ensure queue directory exists
    mkdir -p "$QUEUE_DIR"

    # Scan root queue and priority subdirectories
    local dirs=("$QUEUE_DIR" "$QUEUE_DIR/CRITICAL" "$QUEUE_DIR/HIGH" "$QUEUE_DIR/MEDIUM" "$QUEUE_DIR/LOW")

    for dir in "${dirs[@]}"; do
        [[ -d "$dir" ]] || continue

        while IFS= read -r -d '' file; do
            ((scanned++)) || true
            if register_task "$file"; then
                ((registered++)) || true
            fi
        done < <(find "$dir" -maxdepth 1 -name "*.md" -type f -print0 2>/dev/null)
    done

    LAST_SYNC_TIME=$(date -Iseconds)
    ((SYNC_COUNT++)) || true

    log_debug "M1-002: Queue scan complete (scanned: $scanned, registered: $registered)"
    return 0
}

# Sync completed/failed/review/approved/rejected directories back to SQLite state
# P0.6: Extended to include approved/rejected directories and pending-sync markers
sync_task_states() {
    local dirs_and_states=(
        "${AUTONOMOUS_ROOT}/tasks/running:RUNNING"
        "${AUTONOMOUS_ROOT}/tasks/review:REVIEW"
        "${AUTONOMOUS_ROOT}/tasks/approved:APPROVED"
        "${AUTONOMOUS_ROOT}/tasks/rejected:REJECTED"
        "${AUTONOMOUS_ROOT}/tasks/completed:COMPLETED"
        "${AUTONOMOUS_ROOT}/tasks/failed:FAILED"
    )

    for item in "${dirs_and_states[@]}"; do
        local dir="${item%%:*}"
        local expected_state="${item##*:}"

        [[ -d "$dir" ]] || continue

        while IFS= read -r -d '' file; do
            local filename
            filename=$(basename "$file")
            local task_id="${filename%.md}"
            local esc_id="${task_id//\'/\'\'}"

            # Check current state in SQLite
            local current_state
            current_state=$(_sqlite_exec "$STATE_DB" "SELECT state FROM tasks WHERE id='${esc_id}' LIMIT 1;" 2>/dev/null || echo "")

            if [[ -z "$current_state" ]]; then
                # Task not in SQLite, register it with current state
                _sqlite_exec "$STATE_DB" "INSERT OR IGNORE INTO tasks (id, name, state, created_at, updated_at, trace_id) VALUES ('${esc_id}', '${esc_id}', '${expected_state}', datetime('now'), datetime('now'), '${TRACE_ID}');"
                log_debug "M1-002: Registered missing task $task_id with state $expected_state"
            elif [[ "$current_state" != "$expected_state" ]]; then
                # State mismatch - file location is canonical for terminal/review states
                # P0.6: Added APPROVED and REJECTED to canonical states
                if [[ "$expected_state" == "COMPLETED" || "$expected_state" == "FAILED" || \
                      "$expected_state" == "APPROVED" || "$expected_state" == "REJECTED" ]]; then
                    log_warn "M1-002: State mismatch for $task_id: SQLite=$current_state, File=$expected_state - updating SQLite"
                    _sqlite_exec "$STATE_DB" "UPDATE tasks SET state='${expected_state}', updated_at=datetime('now') WHERE id='${esc_id}';"
                fi
            fi
        done < <(find "$dir" -maxdepth 1 -name "*.md" -type f -print0 2>/dev/null)
    done

    # P0.6: Process pending-sync markers for failed SQLite transitions
    process_pending_sync_markers
}

#===============================================================================
# P0.6: Pending-Sync Marker Processing
#===============================================================================
# Process pending-sync markers created when SQLite transitions fail.
# These markers are created by supervisor-approver.sh and other components
# when they cannot write to SQLite (e.g., database locked, disk full).
# The queue-watcher periodically processes these to ensure eventual consistency.
#===============================================================================

# Process all pending-sync markers
process_pending_sync_markers() {
    local pending_dir="${STATE_DIR}/pending-sync"

    # Skip if directory doesn't exist
    [[ -d "$pending_dir" ]] || return 0

    local marker_count=0
    local success_count=0
    local fail_count=0

    while IFS= read -r -d '' marker_file; do
        ((marker_count++)) || true

        if process_single_pending_marker "$marker_file"; then
            ((success_count++)) || true
        else
            ((fail_count++)) || true
        fi
    done < <(find "$pending_dir" -name "*.pending" -type f -print0 2>/dev/null)

    if [[ $marker_count -gt 0 ]]; then
        log_info "P0.6: Processed $marker_count pending-sync markers (success: $success_count, failed: $fail_count)"
    fi
}

# Process a single pending-sync marker file
# Marker format: {"task_id":"...","target_state":"...","reason":"...","created_at":"...","trace_id":"..."}
process_single_pending_marker() {
    local marker_file="$1"

    if [[ ! -f "$marker_file" ]]; then
        return 0
    fi

    # Read and parse marker content
    local content
    content=$(cat "$marker_file" 2>/dev/null) || {
        log_warn "P0.6: Cannot read pending-sync marker: $marker_file"
        return 1
    }

    # Extract fields from JSON (simple parsing without jq dependency)
    local task_id target_state reason
    task_id=$(echo "$content" | sed -n 's/.*"task_id":"\([^"]*\)".*/\1/p')
    target_state=$(echo "$content" | sed -n 's/.*"target_state":"\([^"]*\)".*/\1/p')
    reason=$(echo "$content" | sed -n 's/.*"reason":"\([^"]*\)".*/\1/p')

    if [[ -z "$task_id" || -z "$target_state" ]]; then
        log_warn "P0.6: Invalid pending-sync marker format: $marker_file"
        # Move to failed markers directory for debugging
        mkdir -p "${STATE_DIR}/pending-sync-failed" 2>/dev/null || true
        mv "$marker_file" "${STATE_DIR}/pending-sync-failed/" 2>/dev/null || rm -f "$marker_file"
        return 1
    fi

    # Validate target state is valid
    case "$target_state" in
        QUEUED|RUNNING|REVIEW|APPROVED|REJECTED|COMPLETED|FAILED|ESCALATED|TIMEOUT|PAUSED|CANCELLED)
            ;;
        *)
            log_warn "P0.6: Invalid target state in marker: $target_state for task $task_id"
            mv "$marker_file" "${STATE_DIR}/pending-sync-failed/" 2>/dev/null || rm -f "$marker_file"
            return 1
            ;;
    esac

    # Escape for SQL
    local esc_id="${task_id//\'/\'\'}"
    local esc_state="${target_state//\'/\'\'}"
    local esc_reason="${reason//\'/\'\'}"

    # Check if task exists in SQLite
    local current_state
    current_state=$(_sqlite_exec "$STATE_DB" "SELECT state FROM tasks WHERE id='${esc_id}' LIMIT 1;" 2>/dev/null || echo "")

    if [[ -z "$current_state" ]]; then
        # Task doesn't exist - create it
        log_info "P0.6: Creating task $task_id with state $target_state from pending-sync marker"
        _sqlite_exec "$STATE_DB" "INSERT OR IGNORE INTO tasks (id, name, state, created_at, updated_at, trace_id) VALUES ('${esc_id}', '${esc_id}', '${esc_state}', datetime('now'), datetime('now'), '${TRACE_ID}');" || {
            log_error "P0.6: Failed to create task $task_id from pending-sync marker"
            return 1
        }
    else
        # Update existing task state
        log_info "P0.6: Updating task $task_id from $current_state to $target_state (from pending-sync)"
        _sqlite_exec "$STATE_DB" "UPDATE tasks SET state='${esc_state}', updated_at=datetime('now') WHERE id='${esc_id}';" || {
            log_error "P0.6: Failed to update task $task_id to state $target_state"
            return 1
        }
    fi

    # Log event for audit trail
    _sqlite_exec "$STATE_DB" "INSERT INTO events (task_id, event_type, actor, payload, trace_id) VALUES ('${esc_id}', 'PENDING_SYNC_PROCESSED', 'queue-watcher', '${esc_reason}', '${TRACE_ID}');" 2>/dev/null || true

    # Remove the processed marker
    rm -f "$marker_file" 2>/dev/null || {
        log_warn "P0.6: Could not remove processed marker: $marker_file"
    }

    log_debug "P0.6: Successfully processed pending-sync marker for $task_id -> $target_state"
    return 0
}

#===============================================================================
# Inotify Monitoring
#===============================================================================

# Check if inotifywait is available
has_inotify() {
    command -v inotifywait &>/dev/null
}

# Watch queue directory with inotify
watch_with_inotify() {
    log_info "M1-002: Using inotify for queue monitoring"

    # Create priority directories if they don't exist
    mkdir -p "$QUEUE_DIR"/{CRITICAL,HIGH,MEDIUM,LOW}

    # Initial sync
    scan_queue

    # Watch for file creation, modification, and movement
    inotifywait -m -r -e create -e moved_to -e modify \
        --format '%w%f' \
        "$QUEUE_DIR" 2>/dev/null |
    while read -r filepath; do
        if [[ "$RUNNING" != "true" ]]; then
            break
        fi

        if [[ "$filepath" == *.md ]]; then
            log_debug "M1-002: Detected file: $filepath"
            register_task "$filepath"
        fi
    done
}

# Polling fallback when inotify is not available
watch_with_polling() {
    log_info "M1-002: Using polling for queue monitoring (interval: ${SYNC_INTERVAL}s)"

    while [[ "$RUNNING" == "true" ]]; do
        scan_queue
        sync_task_states
        sleep "$SYNC_INTERVAL"
    done
}

#===============================================================================
# Status Display
#===============================================================================

show_status() {
    local queued_count=0
    local running_count=0
    local review_count=0

    if command -v sqlite3 &>/dev/null && [[ -f "$STATE_DB" ]]; then
        queued_count=$(sqlite3 "$STATE_DB" "SELECT COUNT(*) FROM tasks WHERE state='QUEUED';" 2>/dev/null || echo "0")
        running_count=$(sqlite3 "$STATE_DB" "SELECT COUNT(*) FROM tasks WHERE state='RUNNING';" 2>/dev/null || echo "0")
        review_count=$(sqlite3 "$STATE_DB" "SELECT COUNT(*) FROM tasks WHERE state='REVIEW';" 2>/dev/null || echo "0")
    fi

    # Count files in queue
    local queue_files=0
    if [[ -d "$QUEUE_DIR" ]]; then
        queue_files=$(find "$QUEUE_DIR" -name "*.md" -type f 2>/dev/null | wc -l)
    fi

    local pid=""
    if [[ -f "$PID_FILE" ]]; then
        pid=$(cat "$PID_FILE" 2>/dev/null || echo "")
        if [[ -n "$pid" ]] && ! kill -0 "$pid" 2>/dev/null; then
            pid=""
        fi
    fi

    cat <<EOF
Queue Watcher Status (v${VERSION}) - M1-002
============================================

Daemon Status:    ${pid:+Running (PID: $pid)}${pid:-Not running}
Inotify Support:  $(has_inotify && echo "Available" || echo "Not available (using polling)")

Queue Statistics:
  Files in queue/: $queue_files
  QUEUED in SQLite: $queued_count
  RUNNING in SQLite: $running_count
  REVIEW in SQLite: $review_count

Sync Statistics:
  Total syncs:     $SYNC_COUNT
  Tasks registered: $TASKS_REGISTERED
  Last sync:       ${LAST_SYNC_TIME:-never}

Queue Directory:  $QUEUE_DIR
Database:         $STATE_DB

EOF

    # Show priority breakdown
    echo "Priority Breakdown (SQLite):"
    if command -v sqlite3 &>/dev/null && [[ -f "$STATE_DB" ]]; then
        sqlite3 "$STATE_DB" <<SQL
SELECT
    CASE priority
        WHEN 0 THEN 'CRITICAL'
        WHEN 1 THEN 'HIGH'
        WHEN 2 THEN 'MEDIUM'
        WHEN 3 THEN 'LOW'
        ELSE 'UNKNOWN'
    END as Priority,
    COUNT(*) as Count
FROM tasks
WHERE state = 'QUEUED'
GROUP BY priority
ORDER BY priority;
SQL
    fi
    echo ""
}

#===============================================================================
# Main
#===============================================================================

main() {
    # Initialize database
    sqlite_state_init "$STATE_DB"

    case "${1:-}" in
        --once)
            log_info "M1-002: Running single queue sync..."
            scan_queue
            sync_task_states
            log_info "M1-002: Sync complete (registered: $TASKS_REGISTERED)"
            ;;

        --status)
            show_status
            ;;

        --help|-h)
            cat <<EOF
tri-agent-queue-watcher - Queue-to-SQLite Bridge Daemon (M1-002)

Usage: tri-agent-queue-watcher [OPTIONS]

Options:
  (none)     Start daemon (uses inotify if available, falls back to polling)
  --once     Single sync and exit
  --status   Show current status
  --help     Show this help

Environment Variables:
  SYNC_INTERVAL    Polling interval in seconds (default: 10)
  USE_INOTIFY      Force inotify mode: auto, yes, no (default: auto)

Description:
  Watches the filesystem queue directory and registers new tasks in SQLite.
  This enables workers to claim tasks atomically via SQLite while allowing
  external systems to create tasks by dropping files into the queue.

Supported File Patterns:
  - tasks/queue/*.md           -> MEDIUM priority (default)
  - tasks/queue/CRITICAL/*.md  -> CRITICAL priority
  - tasks/queue/HIGH/*.md      -> HIGH priority
  - tasks/queue/MEDIUM/*.md    -> MEDIUM priority
  - tasks/queue/LOW/*.md       -> LOW priority
  - CRITICAL_*.md prefix       -> CRITICAL priority (overrides directory)
  - HIGH_*.md prefix           -> HIGH priority

File Metadata (parsed from content):
  - type: <task_type>          -> Task type for worker routing
  - shard: <shard_id>          -> Shard for worker filtering
  - model: <model_name>        -> Assigned model for routing
  - # <Title>                  -> Task name (first H1 heading)

Examples:
  # Start daemon
  ./bin/tri-agent-queue-watcher

  # Single sync
  ./bin/tri-agent-queue-watcher --once

  # Check status
  ./bin/tri-agent-queue-watcher --status
EOF
            ;;

        *)
            # Daemon mode
            log_info "M1-002: Queue watcher daemon starting (v${VERSION})"

            # Write PID file
            mkdir -p "$(dirname "$PID_FILE")"
            echo $$ > "$PID_FILE"

            # Choose monitoring method
            if [[ "$USE_INOTIFY" == "yes" ]] || { [[ "$USE_INOTIFY" == "auto" ]] && has_inotify; }; then
                watch_with_inotify
            else
                watch_with_polling
            fi

            # Cleanup
            rm -f "$PID_FILE"
            log_info "M1-002: Queue watcher daemon stopped"
            ;;
    esac
}

main "$@"

#!/bin/bash
# =============================================================================
# tri-agent-admin - Administrative commands for tri-agent system
# =============================================================================
# Provides queue management, RAG context operations, event store utilities,
# diversity checks, and process reaper controls.
# =============================================================================

set -euo pipefail

# Resolve script location
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
AUTONOMOUS_ROOT="${AUTONOMOUS_ROOT:-$(dirname "$SCRIPT_DIR")}"
LIB_DIR="${AUTONOMOUS_ROOT}/lib"
BIN_DIR="${AUTONOMOUS_ROOT}/bin"

# Source common utilities
if [[ -f "${LIB_DIR}/common.sh" ]]; then
    # shellcheck source=/dev/null
    source "${LIB_DIR}/common.sh"
else
    set -euo pipefail
    AUTONOMOUS_ROOT="${AUTONOMOUS_ROOT:-${HOME}/.claude/autonomous}"
    LIB_DIR="${AUTONOMOUS_ROOT}/lib"
    BIN_DIR="${AUTONOMOUS_ROOT}/bin"
    log_info() { echo "[INFO] $*" >&2; }
    log_warn() { echo "[WARN] $*" >&2; }
    log_error() { echo "[ERROR] $*" >&2; }
fi

# Source libs
[[ -f "${LIB_DIR}/priority-queue.sh" ]] && source "${LIB_DIR}/priority-queue.sh"
[[ -f "${LIB_DIR}/rag-context.sh" ]] && source "${LIB_DIR}/rag-context.sh"
[[ -f "${LIB_DIR}/event-store.sh" ]] && source "${LIB_DIR}/event-store.sh"
[[ -f "${LIB_DIR}/model-diversity.sh" ]] && source "${LIB_DIR}/model-diversity.sh"
[[ -f "${LIB_DIR}/sqlite-state.sh" ]] && source "${LIB_DIR}/sqlite-state.sh"

# Task directories (used by recovery commands)
TASKS_DIR="${TASKS_DIR:-${AUTONOMOUS_ROOT}/tasks}"
STATE_DB="${STATE_DB:-${AUTONOMOUS_ROOT}/state/tri-agent.db}"

COMPONENT="ADMIN"
export COMPONENT

usage() {
    cat <<EOF
tri-agent-admin - Administrative commands

USAGE:
    tri-agent-admin <command> [options]

COMMANDS:
    queue      Manage priority queue
    rag        Manage RAG context store
    events     Manage event store
    diversity  Check model diversity
    reaper     Process reaper controls
    recovery   Task recovery and repair operations
    status     Show system summary

Run "tri-agent-admin <command> --help" for command-specific help.
EOF
}

queue_help() {
    cat <<EOF
tri-agent-admin queue

USAGE:
    tri-agent-admin queue add --priority HIGH --text "..."
    tri-agent-admin queue add --priority HIGH --file task.md [--copy]
    tri-agent-admin queue list
    tri-agent-admin queue next
    tri-agent-admin queue escalate
    tri-agent-admin queue preempt --priority CRITICAL [--reason "..."]
    tri-agent-admin queue current
EOF
}

rag_help() {
    cat <<EOF
tri-agent-admin rag

USAGE:
    tri-agent-admin rag add --source "..." --text "..." [--tags "tag1,tag2"]
    tri-agent-admin rag add --source "..." --file notes.txt [--tags "..."]
    tri-agent-admin rag search "query" [--limit 5]
    tri-agent-admin rag inject "query" [--limit 5] [--full]
    tri-agent-admin rag rollup [--limit 20] [--max-chars 2000]
EOF
}

events_help() {
    cat <<EOF
tri-agent-admin events

USAGE:
    tri-agent-admin events append --type TYPE --payload '{"key":"value"}'
    tri-agent-admin events append --type TYPE --payload-file payload.json
    tri-agent-admin events query [--since ISO] [--until ISO] [--type TYPE] [--limit N]
    tri-agent-admin events rebuild --projection name [--handler count_by_type]
EOF
}

diversity_help() {
    cat <<EOF
tri-agent-admin diversity

USAGE:
    tri-agent-admin diversity score [models...]
    tri-agent-admin diversity select [count] [models...]
    tri-agent-admin diversity report [count] [models...]
EOF
}

reaper_help() {
    cat <<EOF
tri-agent-admin reaper

USAGE:
    tri-agent-admin reaper run [--once|--daemon]
    tri-agent-admin reaper install-cron
    tri-agent-admin reaper uninstall-cron
    tri-agent-admin reaper status
EOF
}

recovery_help() {
    cat <<EOF
tri-agent-admin recovery - Task recovery and repair operations

USAGE:
    tri-agent-admin recovery list-stale [--minutes N]
        List tasks in running/ older than N minutes (default: 30)

    tri-agent-admin recovery requeue-stale [--minutes N] [--dry-run]
        Move stale running tasks back to queue (default: 30 min threshold)

    tri-agent-admin recovery retry-failed <task_id> [--max-retries N]
        Retry a failed task (increment retry count, move to queue)

    tri-agent-admin recovery cleanup-locks [--dry-run]
        Remove orphaned .lock.d directories in tasks/

    tri-agent-admin recovery sync-db [--dry-run]
        Resync SQLite database with filesystem task state

    tri-agent-admin recovery process-pending-sync [--dry-run]
        Process pending-sync markers from failed SQLite transitions

OPTIONS:
    --dry-run    Show what would be done without making changes
    --minutes N  Task age threshold in minutes (default: 30)
    --max-retries N  Maximum retry attempts (default: 3)
EOF
}

status_summary() {
    echo "Queue:"
    pq_list || true

    echo "RAG entries: $(rag_stats 2>/dev/null || echo 0)"
    echo "Events: $(event_store_stats 2>/dev/null || echo 0)"
}

require_arg() {
    local arg="$1"
    local name="$2"
    if [[ -z "$arg" ]]; then
        log_error "Missing value for $name"
        exit 1
    fi
}

cmd_queue() {
    local sub="${1:-}"
    shift || true

    case "$sub" in
        add)
            local priority="MEDIUM"
            local text=""
            local file=""
            local copy=false
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --priority|-p)
                        priority="$2"
                        shift 2
                        ;;
                    --text|-t)
                        text="$2"
                        shift 2
                        ;;
                    --file|-f)
                        file="$2"
                        shift 2
                        ;;
                    --copy)
                        copy=true
                        shift
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done

            if [[ -n "$file" ]]; then
                local mode="move"
                [[ "$copy" == "true" ]] && mode="copy"
                pq_enqueue_file "$priority" "$file" "$mode"
            elif [[ -n "$text" ]]; then
                pq_enqueue_text "$priority" "$text"
            else
                log_error "Provide --text or --file"
                exit 1
            fi
            ;;
        list)
            pq_list
            ;;
        next)
            pq_next_task || true
            ;;
        escalate)
            pq_escalate_waiting
            ;;
        preempt)
            local priority=""
            local reason="preemption"
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --priority|-p)
                        priority="$2"
                        shift 2
                        ;;
                    --reason)
                        reason="$2"
                        shift 2
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            require_arg "$priority" "--priority"
            if pq_preempt_if_needed "$priority" "$reason"; then
                echo "Preempted current task"
            else
                echo "No preemption performed"
            fi
            ;;
        current)
            local current
            current=$(pq_get_current_path || true)
            if [[ -n "$current" ]]; then
                echo "$current"
            else
                echo "No current task"
            fi
            ;;
        --help|-h|"")
            queue_help
            ;;
        *)
            log_error "Unknown queue subcommand: $sub"
            queue_help
            exit 1
            ;;
    esac
}

cmd_rag() {
    local sub="${1:-}"
    shift || true

    case "$sub" in
        add)
            local source=""
            local tags=""
            local text=""
            local file=""
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --source)
                        source="$2"
                        shift 2
                        ;;
                    --tags)
                        tags="$2"
                        shift 2
                        ;;
                    --text)
                        text="$2"
                        shift 2
                        ;;
                    --file)
                        file="$2"
                        shift 2
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            require_arg "$source" "--source"
            if [[ -n "$file" ]]; then
                text=$(cat "$file")
            fi
            require_arg "$text" "--text or --file"
            rag_add_context "$source" "$text" "$tags"
            ;;
        search)
            local query="${1:-}"
            shift || true
            local limit="5"
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --limit)
                        limit="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done
            require_arg "$query" "query"
            rag_search "$query" "$limit"
            ;;
        inject)
            local query="${1:-}"
            shift || true
            local limit="5"
            local full="0"
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --limit)
                        limit="$2"
                        shift 2
                        ;;
                    --full)
                        full="1"
                        shift
                        ;;
                    *)
                        shift
                        ;;
                esac
            done
            require_arg "$query" "query"
            rag_inject_context "$query" "$limit" "$full"
            ;;
        rollup)
            local limit="20"
            local max_chars="2000"
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --limit)
                        limit="$2"
                        shift 2
                        ;;
                    --max-chars)
                        max_chars="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done
            rag_memory_rollup "$limit" "$max_chars"
            ;;
        --help|-h|"")
            rag_help
            ;;
        *)
            log_error "Unknown rag subcommand: $sub"
            rag_help
            exit 1
            ;;
    esac
}

cmd_events() {
    local sub="${1:-}"
    shift || true

    case "$sub" in
        append)
            local type=""
            local payload="{}"
            local payload_file=""
            local metadata="{}"
            local metadata_file=""
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --type)
                        type="$2"
                        shift 2
                        ;;
                    --payload)
                        payload="$2"
                        shift 2
                        ;;
                    --payload-file)
                        payload_file="$2"
                        shift 2
                        ;;
                    --metadata)
                        metadata="$2"
                        shift 2
                        ;;
                    --metadata-file)
                        metadata_file="$2"
                        shift 2
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            require_arg "$type" "--type"
            if [[ -n "$payload_file" ]]; then
                payload=$(cat "$payload_file")
            fi
            if [[ -n "$metadata_file" ]]; then
                metadata=$(cat "$metadata_file")
            fi
            event_append "$type" "$payload" "$metadata"
            ;;
        query)
            local since=""
            local until=""
            local type=""
            local limit=""
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --since)
                        since="$2"
                        shift 2
                        ;;
                    --until)
                        until="$2"
                        shift 2
                        ;;
                    --type)
                        type="$2"
                        shift 2
                        ;;
                    --limit)
                        limit="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done
            event_store_query "$since" "$until" "$type" "$limit"
            ;;
        rebuild)
            local projection=""
            local handler="event_projection_handler_count_by_type"
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --projection)
                        projection="$2"
                        shift 2
                        ;;
                    --handler)
                        handler="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done
            require_arg "$projection" "--projection"
            case "$handler" in
                count_by_type) handler="event_projection_handler_count_by_type" ;;
            esac
            event_projection_rebuild "$projection" "$handler"
            ;;
        --help|-h|"")
            events_help
            ;;
        *)
            log_error "Unknown events subcommand: $sub"
            events_help
            exit 1
            ;;
    esac
}

cmd_diversity() {
    local sub="${1:-}"
    shift || true

    case "$sub" in
        score)
            diversity_score "$@"
            ;;
        select)
            local count="${1:-3}"
            shift || true
            diversity_select "$count" "$@"
            ;;
        report)
            local count="${1:-3}"
            shift || true
            diversity_report "$count" "$@"
            echo ""
            ;;
        --help|-h|"")
            diversity_help
            ;;
        *)
            log_error "Unknown diversity subcommand: $sub"
            diversity_help
            exit 1
            ;;
    esac
}

cmd_reaper() {
    local sub="${1:-}"
    shift || true

    local reaper="${BIN_DIR}/process-reaper"
    if [[ ! -x "$reaper" ]]; then
        log_error "process-reaper not found at $reaper"
        exit 1
    fi

    case "$sub" in
        run)
            "$reaper" "$@"
            ;;
        install-cron)
            "$reaper" --install-cron
            ;;
        uninstall-cron)
            "$reaper" --uninstall-cron
            ;;
        status)
            "$reaper" --status
            ;;
        --help|-h|"")
            reaper_help
            ;;
        *)
            log_error "Unknown reaper subcommand: $sub"
            reaper_help
            exit 1
            ;;
    esac
}

cmd_recovery() {
    local sub="${1:-}"
    shift || true

    case "$sub" in
        list-stale)
            local minutes=30
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --minutes|-m)
                        minutes="$2"
                        shift 2
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            log_info "Listing tasks in running/ older than $minutes minutes..."
            local count=0
            while IFS= read -r -d '' task_file; do
                echo "$task_file"
                count=$((count + 1))
            done < <(find "${TASKS_DIR}/running" -type f -name "*.md" -mmin +"$minutes" -print0 2>/dev/null)
            log_info "Found $count stale task(s)"
            ;;

        requeue-stale)
            local minutes=30
            local dry_run=false
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --minutes|-m)
                        minutes="$2"
                        shift 2
                        ;;
                    --dry-run)
                        dry_run=true
                        shift
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            log_info "Requeuing tasks in running/ older than $minutes minutes..."
            local count=0
            local failed=0
            while IFS= read -r -d '' task_file; do
                local task_name
                task_name=$(basename "$task_file")
                local queue_file="${TASKS_DIR}/queue/${task_name}"
                if [[ "$dry_run" == "true" ]]; then
                    echo "[DRY-RUN] Would move: $task_file -> $queue_file"
                else
                    # Clean up locks to allow new worker to claim
                    rm -f "${task_file}.lock" 2>/dev/null || true
                    rm -rf "${task_file}.lock.d" 2>/dev/null || true

                    if mv "$task_file" "$queue_file" 2>/dev/null; then
                        log_info "Requeued: $task_name"
                        count=$((count + 1))
                    else
                        log_warn "Failed to requeue: $task_name"
                        failed=$((failed + 1))
                    fi
                fi
            done < <(find "${TASKS_DIR}/running" -type f -name "*.md" -mmin +"$minutes" -print0 2>/dev/null)
            log_info "Requeued $count task(s), $failed failed"
            ;;

        retry-failed)
            local task_id="${1:-}"
            shift || true
            local max_retries=3
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --max-retries)
                        max_retries="$2"
                        shift 2
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            require_arg "$task_id" "task_id"
            local task_file="${TASKS_DIR}/failed/${task_id}.md"
            if [[ ! -f "$task_file" ]]; then
                # Try without .md extension
                task_file="${TASKS_DIR}/failed/${task_id}"
                if [[ ! -f "$task_file" ]]; then
                    log_error "Failed task not found: $task_id"
                    exit 1
                fi
            fi
            # Get current retry count
            local retries=0
            if grep -q "^RETRY_COUNT:" "$task_file" 2>/dev/null; then
                retries=$(grep "^RETRY_COUNT:" "$task_file" | head -1 | sed 's/^RETRY_COUNT:[[:space:]]*//' | tr -d '[:space:]')
                retries=${retries:-0}
            fi
            if [[ $retries -ge $max_retries ]]; then
                log_error "Task $task_id has reached max retries ($max_retries)"
                exit 1
            fi
            # Increment retry count
            retries=$((retries + 1))
            if grep -q "^RETRY_COUNT:" "$task_file" 2>/dev/null; then
                sed -i "s/^RETRY_COUNT:.*/RETRY_COUNT: $retries/" "$task_file"
            else
                echo "RETRY_COUNT: $retries" >> "$task_file"
            fi
            # Clean up potential locks (unlikely in failed/, but good hygiene)
            rm -f "${task_file}.lock" 2>/dev/null || true
            rm -rf "${task_file}.lock.d" 2>/dev/null || true

            # Move to queue
            local queue_file="${TASKS_DIR}/queue/$(basename "$task_file")"
            if mv "$task_file" "$queue_file"; then
                log_info "Retrying task $task_id (attempt $retries/$max_retries)"
            else
                log_error "Failed to move task to queue"
                exit 1
            fi
            ;;

        cleanup-locks)
            local dry_run=false
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --dry-run)
                        dry_run=true
                        shift
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            log_info "Cleaning up orphaned .lock.d directories..."
            local count=0
            while IFS= read -r -d '' lock_dir; do
                if [[ "$dry_run" == "true" ]]; then
                    echo "[DRY-RUN] Would remove: $lock_dir"
                else
                    rm -rf "$lock_dir"
                    log_info "Removed: $lock_dir"
                fi
                count=$((count + 1))
            done < <(find "${TASKS_DIR}" -type d -name "*.lock.d" -mmin +60 -print0 2>/dev/null)
            # Also clean up .lock files older than 1 hour
            while IFS= read -r -d '' lock_file; do
                if [[ "$dry_run" == "true" ]]; then
                    echo "[DRY-RUN] Would remove stale lock: $lock_file"
                else
                    rm -f "$lock_file"
                    log_info "Removed stale lock: $lock_file"
                fi
                count=$((count + 1))
            done < <(find "${TASKS_DIR}" -type f -name "*.lock" -mmin +60 -print0 2>/dev/null)
            log_info "Cleaned up $count lock artifact(s)"
            ;;

        sync-db)
            local dry_run=false
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --dry-run)
                        dry_run=true
                        shift
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            if [[ ! -f "$STATE_DB" ]]; then
                log_warn "SQLite database not found at $STATE_DB"
                log_info "Creating database..."
                if [[ "$dry_run" != "true" ]]; then
                    mkdir -p "$(dirname "$STATE_DB")"
                    sqlite3 "$STATE_DB" "CREATE TABLE IF NOT EXISTS tasks (id TEXT PRIMARY KEY, state TEXT, updated_at TEXT);"
                fi
            fi
            log_info "Syncing filesystem state to SQLite..."
            local count=0
            local sql_file
            sql_file=$(mktemp)
            if [[ "$dry_run" != "true" ]]; then
                echo "BEGIN TRANSACTION;" > "$sql_file"
            fi

            for dir in queue running completed failed approved rejected; do
                local task_dir="${TASKS_DIR}/${dir}"
                [[ -d "$task_dir" ]] || continue
                local db_state
                case "$dir" in
                    queue) db_state="QUEUED" ;;
                    running) db_state="RUNNING" ;;
                    completed) db_state="COMPLETED" ;;
                    failed) db_state="FAILED" ;;
                    approved) db_state="APPROVED" ;;
                    rejected) db_state="REJECTED" ;;
                    *) db_state=$(echo "$dir" | tr '[:lower:]' '[:upper:]') ;;
                esac
                for task_file in "$task_dir"/*.md; do
                    [[ -f "$task_file" ]] || continue
                    local task_id
                    task_id=$(basename "$task_file" .md)
                    local now
                    now=$(date -Iseconds)
                    if [[ "$dry_run" == "true" ]]; then
                        echo "[DRY-RUN] Would sync: $task_id -> $db_state"
                    else
                        echo "INSERT OR REPLACE INTO tasks (id, state, updated_at) VALUES ('$task_id', '$db_state', '$now');" >> "$sql_file"
                    fi
                    count=$((count + 1))
                done
            done

            if [[ "$dry_run" != "true" ]]; then
                echo "COMMIT;" >> "$sql_file"
                sqlite3 "$STATE_DB" < "$sql_file"
            fi
            rm -f "$sql_file"
            log_info "Synced $count task(s) to SQLite"
            ;;

        process-pending-sync)
            local dry_run=false
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --dry-run)
                        dry_run=true
                        shift
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            local pending_dir="${AUTONOMOUS_ROOT}/state/pending-sync"
            if [[ ! -d "$pending_dir" ]]; then
                log_info "No pending-sync directory found"
                return 0
            fi
            log_info "Processing pending-sync markers..."
            local count=0
            local failed=0
            for marker in "$pending_dir"/*.json; do
                [[ -f "$marker" ]] || continue
                local task_id target_state
                if command -v jq >/dev/null 2>&1; then
                    task_id=$(jq -r '.task_id' "$marker")
                    target_state=$(jq -r '.target_state' "$marker")
                else
                    task_id=$(grep -o '"task_id":"[^"]*"' "$marker" | cut -d'"' -f4)
                    target_state=$(grep -o '"target_state":"[^"]*"' "$marker" | cut -d'"' -f4)
                fi
                if [[ -z "$task_id" || -z "$target_state" ]]; then
                    log_warn "Invalid marker: $marker"
                    failed=$((failed + 1))
                    continue
                fi
                local now
                now=$(date -Iseconds)
                if [[ "$dry_run" == "true" ]]; then
                    echo "[DRY-RUN] Would sync pending: $task_id -> $target_state"
                else
                    if sqlite3 "$STATE_DB" "INSERT OR REPLACE INTO tasks (id, state, updated_at) VALUES ('$task_id', '$target_state', '$now');" 2>/dev/null; then
                        rm -f "$marker"
                        log_info "Synced pending: $task_id -> $target_state"
                        count=$((count + 1))
                    else
                        log_warn "Failed to sync: $task_id"
                        failed=$((failed + 1))
                    fi
                fi
            done
            log_info "Processed $count pending marker(s), $failed failed"
            ;;

        --help|-h|"")
            recovery_help
            ;;
        *)
            log_error "Unknown recovery subcommand: $sub"
            recovery_help
            exit 1
            ;;
    esac
}

main() {
    local cmd="${1:-}"
    shift || true

    case "$cmd" in
        queue)
            cmd_queue "$@"
            ;;
        rag)
            cmd_rag "$@"
            ;;
        events)
            cmd_events "$@"
            ;;
        diversity)
            cmd_diversity "$@"
            ;;
        reaper)
            cmd_reaper "$@"
            ;;
        recovery)
            cmd_recovery "$@"
            ;;
        status)
            status_summary
            ;;
        --help|-h|"")
            usage
            ;;
        *)
            log_error "Unknown command: $cmd"
            usage
            exit 1
            ;;
    esac
}

main "$@"

# /daemonize - Convert Scripts to systemd Services

> **Version:** 1.0.0 | **Category:** DevOps | **Author:** Ahmed Adel Bakr Alderai

## Purpose

Convert standalone scripts into production-ready systemd services with proper logging, restart policies, resource limits, socket activation, and health checks.

## Arguments

```
$ARGUMENTS - Path to the script to daemonize (required)
             Options: --user (user service), --socket (enable socket activation),
                      --timer (create timer unit), --hardened (security hardening)
```

## Usage Examples

```bash
/daemonize /home/aadel/scripts/my-daemon.sh
/daemonize /opt/app/server.py --socket --hardened
/daemonize /usr/local/bin/backup.sh --timer="*-*-* 03:00:00"
/daemonize ~/.local/bin/agent.sh --user
```

---

## Process

### Phase 1: Script Analysis

Before generating the service unit, analyze the script to determine:

1. **Runtime Requirements**
   - Interpreter (bash, python, node, etc.)
   - Working directory requirements
   - Environment variables needed
   - File/directory dependencies

2. **Service Type Detection**
   - `simple` - Script runs in foreground, does not fork
   - `forking` - Script forks and parent exits
   - `oneshot` - Script runs once and exits
   - `notify` - Script sends sd_notify() when ready
   - `dbus` - Script acquires D-Bus name

3. **Resource Profile**
   - Memory usage estimate
   - CPU requirements
   - Network requirements
   - File descriptor needs

4. **Security Context**
   - Required capabilities
   - Filesystem access patterns
   - Network access requirements
   - User/group requirements

### Phase 2: Generate Service Unit

```bash
# Analysis commands to run:
file "$SCRIPT_PATH"                    # Determine file type
head -1 "$SCRIPT_PATH"                 # Check shebang
ldd "$SCRIPT_PATH" 2>/dev/null         # Check binary dependencies
grep -E '(PORT|SOCKET|LISTEN)' "$SCRIPT_PATH"  # Detect network usage
```

---

## Service Unit Templates

### Template 1: Basic Service (simple)

```ini
# /etc/systemd/system/${SERVICE_NAME}.service
# Generated by /daemonize skill

[Unit]
Description=${DESCRIPTION}
Documentation=man:${SERVICE_NAME}(8)
After=network.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=${SCRIPT_PATH}
ExecReload=/bin/kill -HUP $MAINPID
ExecStop=/bin/kill -TERM $MAINPID

# Process Management
Restart=on-failure
RestartSec=5
RestartPreventExitStatus=0
TimeoutStartSec=30
TimeoutStopSec=30

# User/Group
User=${SERVICE_USER}
Group=${SERVICE_GROUP}

# Working Directory
WorkingDirectory=${WORKING_DIR}

# Environment
Environment="PATH=/usr/local/bin:/usr/bin:/bin"
EnvironmentFile=-/etc/default/${SERVICE_NAME}

# Logging (journald integration)
StandardOutput=journal
StandardError=journal
SyslogIdentifier=${SERVICE_NAME}

[Install]
WantedBy=multi-user.target
```

### Template 2: Forking Service

```ini
[Unit]
Description=${DESCRIPTION}
After=network.target

[Service]
Type=forking
PIDFile=/run/${SERVICE_NAME}/${SERVICE_NAME}.pid
ExecStartPre=/bin/mkdir -p /run/${SERVICE_NAME}
ExecStartPre=/bin/chown ${SERVICE_USER}:${SERVICE_GROUP} /run/${SERVICE_NAME}
ExecStart=${SCRIPT_PATH}
ExecReload=/bin/kill -HUP $MAINPID

Restart=on-failure
RestartSec=10

User=${SERVICE_USER}
Group=${SERVICE_GROUP}
RuntimeDirectory=${SERVICE_NAME}
RuntimeDirectoryMode=0755

StandardOutput=journal
StandardError=journal
SyslogIdentifier=${SERVICE_NAME}

[Install]
WantedBy=multi-user.target
```

### Template 3: Oneshot Service (for tasks)

```ini
[Unit]
Description=${DESCRIPTION}
After=network.target

[Service]
Type=oneshot
ExecStart=${SCRIPT_PATH}
RemainAfterExit=no

User=${SERVICE_USER}
Group=${SERVICE_GROUP}
WorkingDirectory=${WORKING_DIR}

StandardOutput=journal
StandardError=journal
SyslogIdentifier=${SERVICE_NAME}

# No restart for oneshot
Restart=no

[Install]
WantedBy=multi-user.target
```

### Template 4: Notify Service (sd_notify support)

```ini
[Unit]
Description=${DESCRIPTION}
After=network.target

[Service]
Type=notify
NotifyAccess=main
WatchdogSec=30

ExecStart=${SCRIPT_PATH}
ExecReload=/bin/kill -HUP $MAINPID

Restart=on-failure
RestartSec=5

User=${SERVICE_USER}
Group=${SERVICE_GROUP}

StandardOutput=journal
StandardError=journal
SyslogIdentifier=${SERVICE_NAME}

[Install]
WantedBy=multi-user.target
```

---

## Socket Activation Template

### Socket Unit

```ini
# /etc/systemd/system/${SERVICE_NAME}.socket

[Unit]
Description=${SERVICE_NAME} Socket
Documentation=man:${SERVICE_NAME}(8)

[Socket]
# TCP Socket
ListenStream=${LISTEN_ADDRESS}:${LISTEN_PORT}

# Or Unix Socket
# ListenStream=/run/${SERVICE_NAME}/${SERVICE_NAME}.sock
# SocketMode=0660
# SocketUser=${SERVICE_USER}
# SocketGroup=${SERVICE_GROUP}

# Connection handling
Accept=no
MaxConnections=64
KeepAlive=true

# Security
NoDelay=true
ReusePort=true

[Install]
WantedBy=sockets.target
```

### Socket-Activated Service

```ini
# /etc/systemd/system/${SERVICE_NAME}.service

[Unit]
Description=${DESCRIPTION}
Requires=${SERVICE_NAME}.socket
After=${SERVICE_NAME}.socket

[Service]
Type=simple
ExecStart=${SCRIPT_PATH}

# Socket activation - service receives socket from systemd
StandardInput=socket
StandardOutput=journal
StandardError=journal

User=${SERVICE_USER}
Group=${SERVICE_GROUP}

Restart=on-failure
RestartSec=1

# No install section - activated by socket
```

---

## Timer Unit Template (Scheduled Tasks)

### Timer Unit

```ini
# /etc/systemd/system/${SERVICE_NAME}.timer

[Unit]
Description=Timer for ${SERVICE_NAME}
Documentation=man:${SERVICE_NAME}(8)

[Timer]
# Calendar-based scheduling (like cron)
OnCalendar=${SCHEDULE}
# Examples:
# OnCalendar=*-*-* 03:00:00          # Daily at 3 AM
# OnCalendar=Mon *-*-* 00:00:00      # Weekly on Monday
# OnCalendar=*-*-01 00:00:00         # Monthly on 1st
# OnCalendar=hourly                   # Every hour

# Or interval-based
# OnBootSec=5min                     # 5 minutes after boot
# OnUnitActiveSec=1h                 # 1 hour after last run

# Accuracy and randomization
AccuracySec=1min
RandomizedDelaySec=30

# Persistence (run missed executions)
Persistent=true

# Run immediately if missed
OnClockChange=true

[Install]
WantedBy=timers.target
```

### Associated Oneshot Service

```ini
# /etc/systemd/system/${SERVICE_NAME}.service

[Unit]
Description=${DESCRIPTION}
After=network.target

[Service]
Type=oneshot
ExecStart=${SCRIPT_PATH}
RemainAfterExit=no

User=${SERVICE_USER}
Group=${SERVICE_GROUP}
WorkingDirectory=${WORKING_DIR}

StandardOutput=journal
StandardError=journal
SyslogIdentifier=${SERVICE_NAME}

# Resource limits for batch jobs
CPUQuota=50%
MemoryMax=1G
IOWeight=50
Nice=10
```

---

## Health Check Configuration

### Watchdog Integration

```ini
[Service]
# Enable systemd watchdog
WatchdogSec=30
# Service must call sd_notify("WATCHDOG=1") within this interval

# Watchdog failure action
WatchdogSignal=SIGABRT

# Alternative: External health check
ExecStartPost=/bin/sleep 5
ExecStartPost=/usr/local/bin/healthcheck.sh ${SERVICE_NAME}
```

### Health Check Script Template

```bash
#!/bin/bash
# /usr/local/bin/healthcheck.sh
# Health check for systemd services

SERVICE_NAME="$1"
MAX_RETRIES=3
RETRY_DELAY=2

check_health() {
    case "$SERVICE_NAME" in
        *-http*)
            curl -sf http://localhost:${PORT:-8080}/health >/dev/null
            ;;
        *-tcp*)
            nc -z localhost ${PORT:-9000}
            ;;
        *)
            systemctl is-active --quiet "$SERVICE_NAME"
            ;;
    esac
}

for i in $(seq 1 $MAX_RETRIES); do
    if check_health; then
        echo "Health check passed for $SERVICE_NAME"
        exit 0
    fi
    echo "Health check attempt $i failed, retrying in ${RETRY_DELAY}s..."
    sleep $RETRY_DELAY
done

echo "Health check failed for $SERVICE_NAME after $MAX_RETRIES attempts"
exit 1
```

### Notify-Based Health Check (Python Example)

```python
#!/usr/bin/env python3
# Example daemon with sd_notify support

import os
import socket
import time

def notify_systemd(message):
    """Send notification to systemd."""
    addr = os.environ.get('NOTIFY_SOCKET')
    if not addr:
        return

    sock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
    if addr[0] == '@':
        addr = '\0' + addr[1:]
    sock.connect(addr)
    sock.sendall(message.encode())
    sock.close()

def main():
    # Initialization
    print("Starting service...")
    time.sleep(2)  # Simulate startup

    # Signal ready
    notify_systemd("READY=1")
    notify_systemd("STATUS=Running normally")

    # Main loop with watchdog
    while True:
        # Do work...

        # Ping watchdog
        notify_systemd("WATCHDOG=1")
        time.sleep(10)

if __name__ == "__main__":
    main()
```

---

## Resource Limits Configuration

### Memory and CPU Limits

```ini
[Service]
# Memory limits
MemoryMax=2G
MemoryHigh=1G
MemorySwapMax=0

# CPU limits
CPUQuota=200%          # 2 CPU cores max
CPUWeight=100          # Default priority (1-10000)

# IO limits
IOWeight=100           # Default IO priority
IOReadBandwidthMax=/dev/sda 100M
IOWriteBandwidthMax=/dev/sda 50M

# Process limits
TasksMax=100
LimitNOFILE=65535
LimitNPROC=4096
LimitCORE=infinity     # Enable core dumps (or 0 to disable)
```

### Accounting (for monitoring)

```ini
[Service]
# Enable resource accounting
CPUAccounting=true
MemoryAccounting=true
IOAccounting=true
TasksAccounting=true
```

---

## Security Hardening Template

### Hardened Service Unit

```ini
[Service]
# User isolation
User=${SERVICE_USER}
Group=${SERVICE_GROUP}
DynamicUser=false

# Filesystem restrictions
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
PrivateDevices=true
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectKernelLogs=true
ProtectControlGroups=true
ProtectClock=true
ProtectHostname=true

# Read-only paths
ReadOnlyPaths=/etc /usr
ReadWritePaths=${WORKING_DIR} /var/log/${SERVICE_NAME}

# Inaccessible paths
InaccessiblePaths=/root /boot

# Network restrictions
RestrictAddressFamilies=AF_INET AF_INET6 AF_UNIX
IPAddressAllow=localhost
IPAddressDeny=any

# Capability restrictions
CapabilityBoundingSet=
AmbientCapabilities=
NoNewPrivileges=true

# System call filtering
SystemCallFilter=@system-service
SystemCallFilter=~@privileged @resources
SystemCallArchitectures=native

# Namespace isolation
PrivateUsers=true
PrivateNetwork=false
PrivateMounts=true

# Restrict realtime and memory locking
RestrictRealtime=true
LockPersonality=true
MemoryDenyWriteExecute=true

# Restrict suid/sgid
RestrictSUIDSGID=true

# Umask
UMask=0077
```

---

## User Service Template (--user flag)

```ini
# ~/.config/systemd/user/${SERVICE_NAME}.service

[Unit]
Description=${DESCRIPTION}
After=default.target

[Service]
Type=simple
ExecStart=${SCRIPT_PATH}

Restart=on-failure
RestartSec=5

WorkingDirectory=%h
Environment="PATH=%h/.local/bin:/usr/local/bin:/usr/bin:/bin"
EnvironmentFile=-%h/.config/${SERVICE_NAME}/env

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=default.target
```

### User Service Management

```bash
# Enable lingering (services run without login)
loginctl enable-linger ${USER}

# Reload user daemon
systemctl --user daemon-reload

# Enable and start
systemctl --user enable ${SERVICE_NAME}
systemctl --user start ${SERVICE_NAME}

# View logs
journalctl --user -u ${SERVICE_NAME} -f
```

---

## Integration Instructions

### Step 1: Generate the Service Files

```bash
# Create service directory
sudo mkdir -p /etc/systemd/system

# Generate unit file (this skill will output the content)
# Save to: /etc/systemd/system/${SERVICE_NAME}.service

# For user services:
mkdir -p ~/.config/systemd/user
# Save to: ~/.config/systemd/user/${SERVICE_NAME}.service
```

### Step 2: Create Supporting Files

```bash
# Environment file
sudo tee /etc/default/${SERVICE_NAME} << 'EOF'
# Environment variables for ${SERVICE_NAME}
# KEY=value
EOF

# Log directory (if not using journald exclusively)
sudo mkdir -p /var/log/${SERVICE_NAME}
sudo chown ${SERVICE_USER}:${SERVICE_GROUP} /var/log/${SERVICE_NAME}

# Runtime directory
sudo mkdir -p /run/${SERVICE_NAME}
sudo chown ${SERVICE_USER}:${SERVICE_GROUP} /run/${SERVICE_NAME}
```

### Step 3: Reload and Enable

```bash
# Reload systemd configuration
sudo systemctl daemon-reload

# Enable service (start on boot)
sudo systemctl enable ${SERVICE_NAME}

# Start service
sudo systemctl start ${SERVICE_NAME}

# For socket activation
sudo systemctl enable ${SERVICE_NAME}.socket
sudo systemctl start ${SERVICE_NAME}.socket

# For timer
sudo systemctl enable ${SERVICE_NAME}.timer
sudo systemctl start ${SERVICE_NAME}.timer
```

### Step 4: Verify Operation

```bash
# Check service status
sudo systemctl status ${SERVICE_NAME}

# View logs
sudo journalctl -u ${SERVICE_NAME} -f

# Check resource usage
systemctl show ${SERVICE_NAME} --property=MemoryCurrent,CPUUsageNSec

# List active timers
systemctl list-timers --all

# List active sockets
systemctl list-sockets --all
```

---

## Common Patterns

### Pattern 1: Web Server

```bash
/daemonize /opt/app/server.py --socket --hardened
```

Generates socket-activated service on port 8080 with security hardening.

### Pattern 2: Background Worker

```bash
/daemonize /opt/worker/process-queue.sh
```

Generates simple service with automatic restart.

### Pattern 3: Scheduled Backup

```bash
/daemonize /usr/local/bin/backup.sh --timer="*-*-* 02:00:00"
```

Generates oneshot service with daily timer at 2 AM.

### Pattern 4: User Agent

```bash
/daemonize ~/.local/bin/sync-agent.sh --user
```

Generates user-level service without root privileges.

---

## Troubleshooting

### Common Issues

| Issue                  | Cause                | Solution                          |
| ---------------------- | -------------------- | --------------------------------- |
| Service fails to start | Missing dependencies | Check `journalctl -u service -e`  |
| Permission denied      | Wrong user/group     | Verify User= and Group= settings  |
| Socket not created     | SELinux/AppArmor     | Check security contexts           |
| Timer not firing       | Not enabled          | `systemctl enable service.timer`  |
| Watchdog kills service | Not pinging          | Implement sd_notify("WATCHDOG=1") |

### Debug Commands

```bash
# Verbose service status
systemctl status ${SERVICE_NAME} -l

# Service dependencies
systemctl list-dependencies ${SERVICE_NAME}

# Check unit file syntax
systemd-analyze verify /etc/systemd/system/${SERVICE_NAME}.service

# Security analysis
systemd-analyze security ${SERVICE_NAME}

# Boot timeline
systemd-analyze blame
```

---

## Output Format

When invoked, this skill will:

1. Analyze the provided script
2. Determine appropriate service type
3. Generate complete unit file(s)
4. Provide installation commands
5. Include verification steps

```
DAEMONIZE RESULT:
- Script: ${SCRIPT_PATH}
- Service Type: ${SERVICE_TYPE}
- Service Name: ${SERVICE_NAME}
- Files Generated:
  - /etc/systemd/system/${SERVICE_NAME}.service
  - /etc/systemd/system/${SERVICE_NAME}.socket (if --socket)
  - /etc/systemd/system/${SERVICE_NAME}.timer (if --timer)
- Installation Commands: [provided]
- Verification: [provided]
```

---

## References

- systemd.service(5) - Service unit configuration
- systemd.socket(5) - Socket unit configuration
- systemd.timer(5) - Timer unit configuration
- systemd.exec(5) - Execution environment configuration
- systemd.resource-control(5) - Resource control settings
- systemd-analyze(1) - Analyze and debug systemd

---

Ahmed Adel Bakr Alderai
